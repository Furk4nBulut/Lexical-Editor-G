<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/editor/Editor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/Editor.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { ToolbarPlugin } from '../toolbar/Toolbar';&#10;import './styles.css';&#10;import { editorNodes } from './nodes';&#10;import { PageInitializerPlugin } from './plugins/PageInitializerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;} bu&#10;&#10;function initialEditorState(): void {&#10;  // Initial state handled by PageInitializerPlugin&#10;}&#10;&#10;export default function Editor() {&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    editorState: initialEditorState,&#10;    nodes: editorNodes&#10;  } as const;&#10;&#10;  return (&#10;    &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;      &lt;ToolbarPlugin /&gt;&#10;      &lt;div className=&quot;editor-a4-wrapper&quot;&gt;&#10;        &lt;RichTextPlugin&#10;          contentEditable={&lt;ContentEditable className=&quot;editor-a4-content&quot; /&gt;}&#10;          placeholder={&lt;div className=&quot;editor-placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;          ErrorBoundary={LexicalErrorBoundary}&#10;        /&gt;&#10;        &lt;PageInitializerPlugin /&gt;&#10;        &lt;HistoryPlugin /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/LexicalComposer&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { ToolbarPlugin } from '../toolbar/Toolbar';&#10;import './styles.css';&#10;import { editorNodes } from './nodes';&#10;import { PageInitializerPlugin } from './plugins/PageInitializerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;function initialEditorState(): void {&#10;  // Initial state handled by PageInitializerPlugin&#10;}&#10;&#10;export default function Editor() {&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    editorState: initialEditorState,&#10;    nodes: editorNodes&#10;  } as const;&#10;&#10;  return (&#10;    &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;      &lt;ToolbarPlugin /&gt;&#10;      &lt;div className=&quot;editor-a4-wrapper&quot;&gt;&#10;        &lt;RichTextPlugin&#10;          contentEditable={&lt;ContentEditable className=&quot;editor-a4-content&quot; /&gt;}&#10;          placeholder={&lt;div className=&quot;editor-placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;          ErrorBoundary={LexicalErrorBoundary}&#10;        /&gt;&#10;        &lt;PageInitializerPlugin /&gt;&#10;        &lt;HistoryPlugin /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/LexicalComposer&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageContentNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageContentNode.tsx" />
              <option name="originalContent" value="import { DecoratorNode, LexicalNode, NodeKey, SerializedLexicalNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageContentNode = SerializedLexicalNode &amp; {&#10;  type: 'page-content';&#10;  version: 1;&#10;};&#10;&#10;export class PageContentNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  static getType(): string {&#10;    return 'page-content';&#10;  }&#10;&#10;  static clone(node: PageContentNode): PageContentNode {&#10;    return new PageContentNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-content';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  decorate(): JSX.Element {&#10;    return &lt;div className=&quot;a4-content-inner&quot;&gt;{this.getChildren()}&lt;/div&gt;;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageContentNode): PageContentNode {&#10;    return new PageContentNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageContentNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-content',&#10;      version: 1,&#10;    };&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { ElementNode, SerializedElementNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageContentNode = SerializedElementNode &amp; {&#10;  type: 'page-content';&#10;  version: 1;&#10;};&#10;&#10;export class PageContentNode extends ElementNode {&#10;  static getType(): string {&#10;    return 'page-content';&#10;  }&#10;&#10;  static clone(node: PageContentNode): PageContentNode {&#10;    return new PageContentNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-content';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageContentNode): PageContentNode {&#10;    return new PageContentNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageContentNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-content',&#10;      version: 1,&#10;    };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageFooterNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageFooterNode.tsx" />
              <option name="originalContent" value="import { DecoratorNode, LexicalNode, NodeKey, SerializedLexicalNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageFooterNode = SerializedLexicalNode &amp; {&#10;  type: 'page-footer';&#10;  version: 1;&#10;};&#10;&#10;export class PageFooterNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  static getType(): string {&#10;    return 'page-footer';&#10;  }&#10;&#10;  static clone(node: PageFooterNode): PageFooterNode {&#10;    return new PageFooterNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-footer';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  decorate(): JSX.Element {&#10;    return &lt;div className=&quot;a4-footer-inner&quot;&gt;{this.getChildren()}&lt;/div&gt;;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageFooterNode): PageFooterNode {&#10;    return new PageFooterNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageFooterNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-footer',&#10;      version: 1,&#10;    };&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { ElementNode, SerializedElementNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageFooterNode = SerializedElementNode &amp; {&#10;  type: 'page-footer';&#10;  version: 1;&#10;};&#10;&#10;export class PageFooterNode extends ElementNode {&#10;  static getType(): string {&#10;    return 'page-footer';&#10;  }&#10;&#10;  static clone(node: PageFooterNode): PageFooterNode {&#10;    return new PageFooterNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-footer';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageFooterNode): PageFooterNode {&#10;    return new PageFooterNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageFooterNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-footer',&#10;      version: 1,&#10;    };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageHeaderNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageHeaderNode.tsx" />
              <option name="originalContent" value="import { DecoratorNode, LexicalNode, NodeKey, SerializedLexicalNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageHeaderNode = SerializedLexicalNode &amp; {&#10;  type: 'page-header';&#10;  version: 1;&#10;};&#10;&#10;export class PageHeaderNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  static getType(): string {&#10;    return 'page-header';&#10;  }&#10;&#10;  static clone(node: PageHeaderNode): PageHeaderNode {&#10;    return new PageHeaderNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-header';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  decorate(): JSX.Element {&#10;    return &lt;div className=&quot;a4-header-inner&quot;&gt;{this.getChildren()}&lt;/div&gt;;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageHeaderNode): PageHeaderNode {&#10;    return new PageHeaderNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageHeaderNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-header',&#10;      version: 1,&#10;    };&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { ElementNode, SerializedElementNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageHeaderNode = SerializedElementNode &amp; {&#10;  type: 'page-header';&#10;  version: 1;&#10;};&#10;&#10;export class PageHeaderNode extends ElementNode {&#10;  static getType(): string {&#10;    return 'page-header';&#10;  }&#10;&#10;  static clone(node: PageHeaderNode): PageHeaderNode {&#10;    return new PageHeaderNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-header';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageHeaderNode): PageHeaderNode {&#10;    return new PageHeaderNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageHeaderNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-header',&#10;      version: 1,&#10;    };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageNode.tsx" />
              <option name="originalContent" value="import { DecoratorNode, LexicalNode, NodeKey, SerializedLexicalNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageNode = SerializedLexicalNode &amp; {&#10;  type: 'page';&#10;  version: 1;&#10;};&#10;&#10;export class PageNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  static getType(): string {&#10;    return 'page';&#10;  }&#10;&#10;  static clone(node: PageNode): PageNode {&#10;    return new PageNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-page';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  decorate(): JSX.Element {&#10;    return &lt;div className=&quot;a4-page-inner&quot;&gt;{this.getChildren()}&lt;/div&gt;;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageNode): PageNode {&#10;    return new PageNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page',&#10;      version: 1,&#10;    };&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { ElementNode, SerializedElementNode } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedPageNode = SerializedElementNode &amp; {&#10;  type: 'page';&#10;  version: 1;&#10;};&#10;&#10;export class PageNode extends ElementNode {&#10;  static getType(): string {&#10;    return 'page';&#10;  }&#10;&#10;  static clone(node: PageNode): PageNode {&#10;    return new PageNode(node.__key);&#10;  }&#10;&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-page';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageNode): PageNode {&#10;    return new PageNode();&#10;  }&#10;&#10;  exportJSON(): SerializedPageNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page',&#10;      version: 1,&#10;    };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/index.ts" />
              <option name="originalContent" value="import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { PageNode } from './nodes/PageNode';&#10;import { PageHeaderNode } from './nodes/PageHeaderNode';&#10;import { PageContentNode } from './nodes/PageContentNode';&#10;import { PageFooterNode } from './nodes/PageFooterNode';&#10;&#10;export const editorNodes = [&#10;  PageNode,&#10;  PageHeaderNode,&#10;  PageContentNode,&#10;  PageFooterNode,&#10;];&#10;&#10;" />
              <option name="updatedContent" value="import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { PageNode } from './PageNode';&#10;import { PageHeaderNode } from './PageHeaderNode';&#10;import { PageContentNode } from './PageContentNode';&#10;import { PageFooterNode } from './PageFooterNode';&#10;&#10;export const editorNodes = [&#10;  PageNode,&#10;  PageHeaderNode,&#10;  PageContentNode,&#10;  PageFooterNode,&#10;];" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/PageInitializerPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/PageInitializerPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot, $createParagraphNode } from 'lexical';&#10;import { useEffect } from 'react';&#10;import { PageNode } from '../nodes/PageNode';&#10;import { PageHeaderNode } from '../nodes/PageHeaderNode';&#10;import { PageContentNode } from '../nodes/PageContentNode';&#10;&#10;export function PageInitializerPlugin() {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      if (root.getChildrenSize() === 0) {&#10;        const page = new PageNode();&#10;        const header = new PageHeaderNode();&#10;        page.append(header);&#10;        root.append(page);&#10;      }&#10;    });&#10;  }, [editor]);&#10;&#10;  return null;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect } from 'react';&#10;import { PageNode } from '../nodes/PageNode';&#10;&#10;export function PageInitializerPlugin() {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      if (root.getChildrenSize() === 0) {&#10;        const page = new PageNode();&#10;        // Do not add header or footer by default&#10;        root.append(page);&#10;      }&#10;    });&#10;  }, [editor]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/styles.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/styles.css" />
              <option name="originalContent" value=".editor-a4-wrapper {&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: flex-start;&#10;  min-height: 100vh;&#10;  background: #f4f4f4;&#10;  padding: 40px 0;&#10;}&#10;&#10;.editor-a4-content {&#10;  outline: none;&#10;  width: 210mm;&#10;  min-height: 297mm;&#10;  background: #fff;&#10;  box-shadow: 0 0 8px rgba(0,0,0,0.12);&#10;  border-radius: 4px;&#10;  padding: 0;&#10;  position: relative;&#10;  font-size: 16px;&#10;  box-sizing: border-box;&#10;}&#10;&#10;.a4-page {&#10;  width: 210mm;&#10;  min-height: 297mm;&#10;  margin: 0 auto;&#10;  background: transparent;&#10;  position: relative;&#10;  display: flex;&#10;  flex-direction: column;&#10;  box-sizing: border-box;&#10;}&#10;&#10;.a4-header {&#10;  min-height: 32mm;&#10;  max-height: 50mm;&#10;  background: none;&#10;  border-bottom: 1px solid #e0e0e0;&#10;  padding: 16px 24px 8px 24px;&#10;  font-weight: bold;&#10;  font-size: 18px;&#10;  color: #333;&#10;}&#10;&#10;.a4-content {&#10;  flex: 1;&#10;  min-height: 180mm;&#10;  background: none;&#10;  padding: 16px 24px;&#10;  color: #222;&#10;}&#10;&#10;.a4-footer {&#10;  min-height: 20mm;&#10;  max-height: 40mm;&#10;  background: none;&#10;  border-top: 1px solid #e0e0e0;&#10;  padding: 8px 24px 16px 24px;&#10;  font-size: 14px;&#10;  color: #666;&#10;}&#10;&#10;.editor-placeholder {&#10;  position: absolute;&#10;  left: 32px;&#10;  top: 32px;&#10;  color: #bbb;&#10;  pointer-events: none;&#10;  font-size: 16px;&#10;}&#10;&#10;" />
              <option name="updatedContent" value=".editor-a4-wrapper {&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: flex-start;&#10;  min-height: 100vh;&#10;  background: #f4f4f4;&#10;  padding: 40px 0;&#10;}&#10;&#10;.editor-a4-content {&#10;  outline: none;&#10;  width: 210mm;&#10;  min-height: 297mm;&#10;  background: #fff;&#10;  box-shadow: 0 0 16px rgba(0,0,0,0.14);&#10;  border-radius: 8px;&#10;  padding: 0;&#10;  position: relative;&#10;  font-size: 16px;&#10;  box-sizing: border-box;&#10;  margin-top: 24px;&#10;  margin-bottom: 24px;&#10;  transition: box-shadow 0.2s;&#10;}&#10;.editor-a4-content:focus {&#10;  box-shadow: 0 0 24px rgba(0,0,0,0.18);&#10;}&#10;&#10;.a4-page {&#10;  width: 210mm;&#10;  min-height: 297mm;&#10;  margin: 0 auto;&#10;  background: transparent;&#10;  position: relative;&#10;  display: flex;&#10;  flex-direction: column;&#10;  box-sizing: border-box;&#10;  border-radius: 8px;&#10;  overflow: hidden;&#10;}&#10;&#10;.a4-header {&#10;  min-height: 32mm;&#10;  max-height: 50mm;&#10;  background: #f8fafc;&#10;  border-bottom: 1px solid #e0e0e0;&#10;  padding: 18px 32px 10px 32px;&#10;  font-weight: 600;&#10;  font-size: 20px;&#10;  color: #333;&#10;  letter-spacing: 0.01em;&#10;  border-top-left-radius: 8px;&#10;  border-top-right-radius: 8px;&#10;}&#10;&#10;.a4-content {&#10;  flex: 1;&#10;  min-height: 180mm;&#10;  background: none;&#10;  padding: 24px 32px;&#10;  color: #222;&#10;  font-size: 16px;&#10;  line-height: 1.7;&#10;}&#10;&#10;.a4-footer {&#10;  min-height: 20mm;&#10;  max-height: 40mm;&#10;  background: #f8fafc;&#10;  border-top: 1px solid #e0e0e0;&#10;  padding: 10px 32px 18px 32px;&#10;  font-size: 15px;&#10;  color: #666;&#10;  border-bottom-left-radius: 8px;&#10;  border-bottom-right-radius: 8px;&#10;}&#10;&#10;.editor-placeholder {&#10;  position: absolute;&#10;  left: 40px;&#10;  top: 40px;&#10;  color: #bbb;&#10;  pointer-events: none;&#10;  font-size: 16px;&#10;}&#10;&#10;.toolbarRoot {&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  gap: 16px;&#10;  background: #fff;&#10;  border-radius: 8px;&#10;  box-shadow: 0 2px 8px rgba(0,0,0,0.07);&#10;  padding: 10px 24px;&#10;  margin: 0 auto 16px auto;&#10;  width: fit-content;&#10;  min-width: 320px;&#10;  position: sticky;&#10;  top: 0;&#10;  z-index: 10;&#10;}&#10;&#10;.toolbarGroup {&#10;  display: flex;&#10;  gap: 8px;&#10;}&#10;&#10;.toolbarButton {&#10;  background: #f4f4f4;&#10;  border: none;&#10;  border-radius: 6px;&#10;  padding: 6px 12px;&#10;  font-size: 15px;&#10;  color: #333;&#10;  cursor: pointer;&#10;  transition: background 0.15s, color 0.15s;&#10;  outline: none;&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 4px;&#10;}&#10;.toolbarButton.active, .toolbarButton:active, .toolbarButton:focus {&#10;  background: #2563eb;&#10;  color: #fff;&#10;}&#10;.toolbarButton:hover {&#10;  background: #e0e7ff;&#10;  color: #2563eb;&#10;}&#10;&#10;@media (max-width: 900px) {&#10;  .editor-a4-content, .a4-page {&#10;    width: 100vw;&#10;    min-width: 0;&#10;    border-radius: 0;&#10;  }&#10;  .a4-header, .a4-content, .a4-footer {&#10;    padding-left: 12px;&#10;    padding-right: 12px;&#10;  }&#10;  .toolbarRoot {&#10;    min-width: 0;&#10;    width: 100vw;&#10;    border-radius: 0;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import {&#10;  DEFAULT_PAGINATION_SETTINGS,&#10;  type PaginationSettings&#10;} from './plugins/pagination/PaginationSettings';&#10;import { PageBreakNode } from './plugins/pagination/PageBreakNode';&#10;import { WordCountPlugin } from './plugins/WordCountPlugin';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import './styles.css';&#10;import { BannerNode, BannerPlugin } from './plugins/banner/BannerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;export default function Editor({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): JSX.Element {&#10;  const [pageCount, setPageCount] = React.useState(1);&#10;  const paginationSettings: PaginationSettings = DEFAULT_PAGINATION_SETTINGS;&#10;&#10;  const handlePageCountChange = React.useCallback((count: number) =&gt; {&#10;    setPageCount(count);&#10;  }, []);&#10;&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [PageBreakNode, BannerNode]&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-container paginated&quot;&gt;&#10;      &lt;div className=&quot;page-indicator&quot;&gt;Page {pageCount}&lt;/div&gt;&#10;      &lt;div&#10;        className=&quot;a4-page&quot;&#10;        style={{&#10;          width: `${paginationSettings.pageWidth}mm`,&#10;          minHeight: `${paginationSettings.pageHeight}mm`,&#10;          margin: `${paginationSettings.marginTop}mm ${paginationSettings.marginRight}mm ${paginationSettings.marginBottom}mm ${paginationSettings.marginLeft}mm`&#10;        }}&#10;      &gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;ToolbarPlugin /&gt;&#10;          &lt;BannerPlugin /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;            placeholder={&lt;div className=&quot;placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;PaginationPlugin&#10;            settings={paginationSettings}&#10;            onPageCountChange={handlePageCountChange}&#10;          /&gt;&#10;          &lt;WordCountPlugin onWordCountChange={onWordCountChange} /&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { PaginationPlugin } from './plugins/pagination/PaginationPlugin';&#10;import { DEFAULT_PAGINATION_SETTINGS, type PaginationSettings } from './plugins/pagination/PaginationSettings';&#10;import { PageBreakNode } from './plugins/pagination/PageBreakNode';&#10;import { WordCountPlugin } from './plugins/WordCountPlugin';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import './styles.css';&#10;import { BannerNode, BannerPlugin } from './plugins/banner/BannerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;export default function Editor({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): JSX.Element {&#10;  const [pageCount, setPageCount] = React.useState(1);&#10;  const paginationSettings: PaginationSettings = DEFAULT_PAGINATION_SETTINGS;&#10;&#10;  const handlePageCountChange = React.useCallback((count: number) =&gt; {&#10;    setPageCount(count);&#10;  }, []);&#10;&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [PageBreakNode, BannerNode]&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-container paginated&quot;&gt;&#10;      &lt;div className=&quot;page-indicator&quot;&gt;Page {pageCount}&lt;/div&gt;&#10;      &lt;div&#10;        className=&quot;a4-page&quot;&#10;        style={{&#10;          width: `${paginationSettings.pageWidth}mm`,&#10;          minHeight: `${paginationSettings.pageHeight}mm`,&#10;          margin: `${paginationSettings.marginTop}mm ${paginationSettings.marginRight}mm ${paginationSettings.marginBottom}mm ${paginationSettings.marginLeft}mm`&#10;        }}&#10;      &gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;ToolbarPlugin /&gt;&#10;          &lt;BannerPlugin /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;            placeholder={&lt;div className=&quot;placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;PaginationPlugin&#10;            settings={paginationSettings}&#10;            onPageCountChange={handlePageCountChange}&#10;          /&gt;&#10;          &lt;WordCountPlugin onWordCountChange={onWordCountChange} /&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/WordCountPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/WordCountPlugin.tsx" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEffect } from 'react';&#10;import { $getRoot } from 'lexical';&#10;&#10;export function WordCountPlugin({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(() =&gt; {&#10;      editor.getEditorState().read(() =&gt; {&#10;        const text = $getRoot().getTextContent();&#10;        const words = text.trim().split(/\s+/).filter((word) =&gt; word.length &gt; 0).length;&#10;        const chars = text.length;&#10;        onWordCountChange?.(words, chars);&#10;      });&#10;    });&#10;  }, [editor, onWordCountChange]);&#10;&#10;  return null;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, type PageBreakNode } from './PageBreakNode';&#10;&#10;export interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;export const DEFAULT_PAGINATION_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210, // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20&#10;};&#10;&#10;export const PAGINATION_PRESETS: Record&lt;string, Partial&lt;PaginationSettings&gt;&gt; = {&#10;  A4: { pageWidth: 210, pageHeight: 297 },&#10;  A3: { pageWidth: 297, pageHeight: 420 },&#10;  Letter: { pageWidth: 216, pageHeight: 279 },&#10;  Legal: { pageWidth: 216, pageHeight: 356 }&#10;};&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_PAGINATION_SETTINGS,&#10;  onPageCountChange&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const finalSettings = { ...DEFAULT_PAGINATION_SETTINGS, ...settings };&#10;  const contentHeight =&#10;    finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: Array&lt;{ index: number; pageNumber: number }&gt; = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Collect existing page breaks&#10;      children.forEach((child) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach((pageBreak) =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element !== null) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const nodeAtIndex = root.getChildAtIndex(index);&#10;        if (nodeAtIndex !== null) {&#10;          const pageBreak = $createPageBreakNode(pageNumber);&#10;          nodeAtIndex.insertBefore(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      onPageCountChange?.(newPageCount);&#10;    });&#10;  }, [editor, contentHeight, onPageCountChange]);&#10;&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; {&#10;      clearTimeout(timer);&#10;    };&#10;  }, [checkForPageBreak]);&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ dirtyElements, dirtyLeaves }) =&gt; {&#10;      if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;        setTimeout(() =&gt; {&#10;          checkForPageBreak();&#10;        }, 100);&#10;      }&#10;    });&#10;  }, [editor, checkForPageBreak]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, type PageBreakNode } from './PageBreakNode';&#10;import { PaginationSettings, DEFAULT_PAGINATION_SETTINGS, PAGINATION_PRESETS } from './PaginationSettings';&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_PAGINATION_SETTINGS,&#10;  onPageCountChange&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const finalSettings = { ...DEFAULT_PAGINATION_SETTINGS, ...settings };&#10;  const contentHeight =&#10;    finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: Array&lt;{ index: number; pageNumber: number }&gt; = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Collect existing page breaks&#10;      children.forEach((child) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach((pageBreak) =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element !== null) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const nodeAtIndex = root.getChildAtIndex(index);&#10;        if (nodeAtIndex !== null) {&#10;          const pageBreak = $createPageBreakNode(pageNumber);&#10;          nodeAtIndex.insertBefore(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      onPageCountChange?.(newPageCount);&#10;    });&#10;  }, [editor, contentHeight, onPageCountChange]);&#10;&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; {&#10;      clearTimeout(timer);&#10;    };&#10;  }, [checkForPageBreak]);&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ dirtyElements, dirtyLeaves }) =&gt; {&#10;      if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;        setTimeout(() =&gt; {&#10;          checkForPageBreak();&#10;        }, 100);&#10;      }&#10;    });&#10;  }, [editor, checkForPageBreak]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettingsPanel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettingsPanel.tsx" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import type { PaginationSettings } from './PaginationPlugin';&#10;&#10;interface PaginationSettingsProps {&#10;  settings: PaginationSettings;&#10;  onSettingsChange: (settings: PaginationSettings) =&gt; void;&#10;  isVisible: boolean;&#10;  onToggle: () =&gt; void;&#10;}&#10;&#10;export function PaginationSettingsPanel({&#10;  settings,&#10;  onSettingsChange,&#10;  isVisible,&#10;  onToggle&#10;}: PaginationSettingsProps): JSX.Element {&#10;  const [localSettings, setLocalSettings] = useState(settings);&#10;&#10;  const handleChange = (field: keyof PaginationSettings, value: number): void =&gt; {&#10;    const newSettings = { ...localSettings, [field]: value };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  const presets = {&#10;    A4: { pageWidth: 210, pageHeight: 297 },&#10;    A3: { pageWidth: 297, pageHeight: 420 },&#10;    Letter: { pageWidth: 216, pageHeight: 279 },&#10;    Legal: { pageWidth: 216, pageHeight: 356 }&#10;  };&#10;&#10;  const applyPreset = (preset: keyof typeof presets): void =&gt; {&#10;    const newSettings = {&#10;      ...localSettings,&#10;      ...presets[preset]&#10;    };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  if (!isVisible) {&#10;    return (&#10;      &lt;button className=&quot;pagination-control-btn settings-toggle&quot; onClick={onToggle}&gt;&#10;        ⚙️&#10;      &lt;/button&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;page-settings&quot;&gt;&#10;      &lt;div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}&gt;&#10;        &lt;h3&gt;Sayfa Ayarları&lt;/h3&gt;&#10;        &lt;button&#10;          onClick={onToggle}&#10;          style={{&#10;            background: 'none',&#10;            border: 'none',&#10;            cursor: 'pointer',&#10;            fontSize: '16px'&#10;          }}&#10;        &gt;&#10;          ✕&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div style={{ marginBottom: '12px' }}&gt;&#10;        &lt;label&gt;Sayfa Boyutu Önayarları:&lt;/label&gt;&#10;        &lt;div style={{ display: 'flex', gap: '4px', marginTop: '4px' }}&gt;&#10;          {Object.keys(presets).map((preset) =&gt; (&#10;            &lt;button&#10;              key={preset}&#10;              onClick={() =&gt; {&#10;                applyPreset(preset as keyof typeof presets);&#10;              }}&#10;              style={{&#10;                padding: '4px 8px',&#10;                border: '1px solid #d1d1d1',&#10;                borderRadius: '2px',&#10;                background: 'white',&#10;                cursor: 'pointer',&#10;                fontSize: '10px'&#10;              }}&#10;            &gt;&#10;              {preset}&#10;            &lt;/button&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;label&gt;&#10;        Genişlik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageWidth}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageWidth', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;500&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Yükseklik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageHeight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageHeight', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;700&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Üst Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginTop}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginTop', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Alt Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginBottom}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginBottom', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sol Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginLeft}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginLeft', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sağ Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginRight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginRight', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;div style={{ marginTop: '12px', fontSize: '10px', color: '#666' }}&gt;&#10;        Ctrl+Enter: Yeni sayfa ekle&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="export interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;export const DEFAULT_PAGINATION_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210,  // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20&#10;};&#10;&#10;export const PAGINATION_PRESETS: Record&lt;string, Partial&lt;PaginationSettings&gt;&gt; = {&#10;  A4: { pageWidth: 210, pageHeight: 297 },&#10;  A3: { pageWidth: 297, pageHeight: 420 },&#10;  Letter: { pageWidth: 216, pageHeight: 279 },&#10;  Legal: { pageWidth: 216, pageHeight: 356 }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/toolbar/PageSectionVisibilityToolbar.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/toolbar/PageSectionVisibilityToolbar.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { PageHeaderNode } from '../editor/nodes/PageHeaderNode';&#10;import { PageFooterNode } from '../editor/nodes/PageFooterNode';&#10;import { PageNode } from '../editor/nodes/PageNode';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;&#10;export function PageSectionVisibilityToolbar() {&#10;  const [editor] = useLexicalComposerContext();&#10;  const [hasHeader, setHasHeader] = React.useState(false);&#10;  const [hasFooter, setHasFooter] = React.useState(false);&#10;&#10;  // Header/footer state'ini güncel tutmak için Lexical'ın updateListener'ını kullan&#10;  React.useEffect(() =&gt; {&#10;    // Listener'ı sadece bir kez ekle, her editörde bir tane olsun&#10;    const unregister = editor.registerUpdateListener(({ editorState }) =&gt; {&#10;      editorState.read(() =&gt; {&#10;        const root = $getRoot();&#10;        const page = root.getFirstChild();&#10;        if (page instanceof PageNode) {&#10;          // getChildren() her zaman güncel state'i döner&#10;          setHasHeader(!!(page.getChildren().find(child =&gt; child instanceof PageHeaderNode)));&#10;          setHasFooter(!!(page.getChildren().find(child =&gt; child instanceof PageFooterNode)));&#10;        } else {&#10;          setHasHeader(false);&#10;          setHasFooter(false);&#10;        }&#10;      });&#10;    });&#10;    return unregister;&#10;  }, [editor]);&#10;&#10;  const ensureContentNode = (page: PageNode) =&gt; {&#10;    const hasContent = !!page.getChildren().find(child =&gt; child.getType() === 'page-content');&#10;    if (!hasContent) {&#10;      const { PageContentNode } = require('../editor/nodes/PageContentNode');&#10;      const contentNode = new PageContentNode();&#10;      // Header varsa onun sonrasına, yoksa en başa ekle&#10;      const header = page.getChildren().find(child =&gt; child instanceof PageHeaderNode);&#10;      if (header) {&#10;        header.insertAfter(contentNode);&#10;      } else {&#10;        page.append(contentNode);&#10;      }&#10;    }&#10;  };&#10;&#10;  const toggleHeader = () =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const page = root.getFirstChild();&#10;      if (page instanceof PageNode) {&#10;        const header = page.getChildren().find(child =&gt; child instanceof PageHeaderNode);&#10;        if (header) {&#10;          header.remove();&#10;        } else {&#10;          const newHeader = new PageHeaderNode();&#10;          page.insertBefore(newHeader, page.getFirstChild());&#10;          ensureContentNode(page);&#10;        }&#10;      }&#10;    });&#10;  };&#10;&#10;  const toggleFooter = () =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const page = root.getFirstChild();&#10;      if (page instanceof PageNode) {&#10;        const footer = page.getChildren().find(child =&gt; child instanceof PageFooterNode);&#10;        if (footer) {&#10;          footer.remove();&#10;        } else {&#10;          const newFooter = new PageFooterNode();&#10;          ensureContentNode(page);&#10;          // Footer'ı en sona ekle&#10;          const children = page.getChildren();&#10;          const last = children[children.length - 1];&#10;          if (last &amp;&amp; last.getType() === 'page-content') {&#10;            last.insertAfter(newFooter);&#10;          } else {&#10;            page.append(newFooter);&#10;          }&#10;        }&#10;      }&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;Toolbar.Button&#10;        className={hasHeader ? 'toolbarButton active' : 'toolbarButton'}&#10;        onClick={toggleHeader}&#10;        title={hasHeader ? 'Remove Header' : 'Add Header'}&#10;      &gt;&#10;        {hasHeader ? 'Remove Header' : 'Add Header'}&#10;      &lt;/Toolbar.Button&gt;&#10;      &lt;Toolbar.Button&#10;        className={hasFooter ? 'toolbarButton active' : 'toolbarButton'}&#10;        onClick={toggleFooter}&#10;        title={hasFooter ? 'Remove Footer' : 'Add Footer'}&#10;      &gt;&#10;        {hasFooter ? 'Remove Footer' : 'Add Footer'}&#10;      &lt;/Toolbar.Button&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { PageHeaderNode } from '../editor/nodes/PageHeaderNode';&#10;import { PageFooterNode } from '../editor/nodes/PageFooterNode';&#10;import { PageNode } from '../editor/nodes/PageNode';&#10;import { PageContentNode } from '../editor/nodes/PageContentNode';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;&#10;export function PageSectionVisibilityToolbar() {&#10;  const [editor] = useLexicalComposerContext();&#10;  const [hasHeader, setHasHeader] = React.useState(false);&#10;  const [hasFooter, setHasFooter] = React.useState(false);&#10;&#10;  // Header/footer state'ini güncel tutmak için Lexical'ın updateListener'ını kullan&#10;  React.useEffect(() =&gt; {&#10;    // Listener'ı sadece bir kez ekle, her editörde bir tane olsun&#10;    const unregister = editor.registerUpdateListener(({ editorState }) =&gt; {&#10;      editorState.read(() =&gt; {&#10;        const root = $getRoot();&#10;        const page = root.getFirstChild();&#10;        if (page instanceof PageNode) {&#10;          // getChildren() her zaman güncel state'i döner&#10;          setHasHeader(!!(page.getChildren().find(child =&gt; child instanceof PageHeaderNode)));&#10;          setHasFooter(!!(page.getChildren().find(child =&gt; child instanceof PageFooterNode)));&#10;        } else {&#10;          setHasHeader(false);&#10;          setHasFooter(false);&#10;        }&#10;      });&#10;    });&#10;    return unregister;&#10;  }, [editor]);&#10;&#10;  const ensureContentNode = (page: PageNode) =&gt; {&#10;    const hasContent = !!page.getChildren().find(child =&gt; child.getType() === 'page-content');&#10;    if (!hasContent) {&#10;      const contentNode = new PageContentNode();&#10;      // Header varsa onun sonrasına, yoksa en başa ekle&#10;      const header = page.getChildren().find(child =&gt; child instanceof PageHeaderNode);&#10;      if (header) {&#10;        header.insertAfter(contentNode);&#10;      } else {&#10;        page.append(contentNode);&#10;      }&#10;    }&#10;  };&#10;&#10;  const toggleHeader = () =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const page = root.getFirstChild();&#10;      if (page instanceof PageNode) {&#10;        const header = page.getChildren().find(child =&gt; child instanceof PageHeaderNode);&#10;        if (header) {&#10;          header.remove();&#10;        } else {&#10;          const newHeader = new PageHeaderNode();&#10;          page.insertBefore(newHeader, page.getFirstChild());&#10;          ensureContentNode(page);&#10;        }&#10;      }&#10;    });&#10;  };&#10;&#10;  const toggleFooter = () =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const page = root.getFirstChild();&#10;      if (page instanceof PageNode) {&#10;        const footer = page.getChildren().find(child =&gt; child instanceof PageFooterNode);&#10;        if (footer) {&#10;          footer.remove();&#10;        } else {&#10;          const newFooter = new PageFooterNode();&#10;          ensureContentNode(page);&#10;          // Footer'ı en sona ekle&#10;          const children = page.getChildren();&#10;          const last = children[children.length - 1];&#10;          if (last &amp;&amp; last.getType() === 'page-content') {&#10;            last.insertAfter(newFooter);&#10;          } else {&#10;            page.append(newFooter);&#10;          }&#10;        }&#10;      }&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;Toolbar.Button&#10;        className={hasHeader ? 'toolbarButton active' : 'toolbarButton'}&#10;        onClick={toggleHeader}&#10;        title={hasHeader ? 'Remove Header' : 'Add Header'}&#10;      &gt;&#10;        {hasHeader ? 'Remove Header' : 'Add Header'}&#10;      &lt;/Toolbar.Button&gt;&#10;      &lt;Toolbar.Button&#10;        className={hasFooter ? 'toolbarButton active' : 'toolbarButton'}&#10;        onClick={toggleFooter}&#10;        title={hasFooter ? 'Remove Footer' : 'Add Footer'}&#10;      &gt;&#10;        {hasFooter ? 'Remove Footer' : 'Add Footer'}&#10;      &lt;/Toolbar.Button&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/toolbar/Toolbar.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/toolbar/Toolbar.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $setBlocksType_experimental } from '@lexical/selection';&#10;import { $isRangeSelection, $getSelection, type TextFormatType } from 'lexical';&#10;import { $createHeadingNode } from '@lexical/rich-text';&#10;import { INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND } from '@lexical/list';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;import {&#10;  StrikethroughIcon,&#10;  FontBoldIcon,&#10;  FontItalicIcon,&#10;  UnderlineIcon,&#10;} from '@radix-ui/react-icons';&#10;import { OrderedListIcon, UnorderedListIcon } from './icons';&#10;import { PageSectionVisibilityToolbar } from './PageSectionVisibilityToolbar';&#10;&#10;&#10;interface ToolbarButtonProps {&#10;  className?: string;&#10;  onClick?: () =&gt; void;&#10;  title?: string;&#10;  children: React.ReactNode;&#10;}&#10;&#10;function ToolbarButton(props: ToolbarButtonProps): JSX.Element {&#10;  const { className, onClick, title, children, ...rest } = props;&#10;  return (&#10;    &lt;Toolbar.Button&#10;      className={`toolbarButton ${className ?? ''}`}&#10;      onClick={onClick}&#10;      title={title}&#10;      {...rest}&#10;    &gt;&#10;      {children}&#10;    &lt;/Toolbar.Button&gt;&#10;  );&#10;}&#10;&#10;function TextFormatToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const getIcon = (format: TextFormatType): JSX.Element | null =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return &lt;FontBoldIcon /&gt;;&#10;      case 'italic':&#10;        return &lt;FontItalicIcon /&gt;;&#10;      case 'strikethrough':&#10;        return &lt;StrikethroughIcon /&gt;;&#10;      case 'underline':&#10;        return &lt;UnderlineIcon /&gt;;&#10;      default:&#10;        return null;&#10;    }&#10;  };&#10;&#10;  const getTitle = (format: TextFormatType): string =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return 'Kalın (Ctrl+B)';&#10;      case 'italic':&#10;        return 'İtalik (Ctrl+I)';&#10;      case 'underline':&#10;        return 'Alt çizgi (Ctrl+U)';&#10;      case 'strikethrough':&#10;        return 'Üstü çizili';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (format: TextFormatType): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        selection.formatText(format);&#10;      }&#10;    });&#10;  };&#10;&#10;  const supportedTextFormats: TextFormatType[] = ['bold', 'italic', 'underline', 'strikethrough'];&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {supportedTextFormats.map((format) =&gt; (&#10;        &lt;ToolbarButton&#10;          key={format}&#10;          onClick={() =&gt; {&#10;            onClick(format);&#10;          }}&#10;          title={getTitle(format)}&#10;          data-format&#10;        &gt;&#10;          {getIcon(format)}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;&#10;type HeadingTag = 'h1' | 'h2' | 'h3';&#10;function HeadingToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const headingTags: HeadingTag[] = ['h1', 'h2', 'h3'];&#10;&#10;  const getTitle = (tag: HeadingTag): string =&gt; {&#10;    switch (tag) {&#10;      case 'h1':&#10;        return 'Başlık 1';&#10;      case 'h2':&#10;        return 'Başlık 2';&#10;      case 'h3':&#10;        return 'Başlık 3';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (tag: HeadingTag): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        $setBlocksType_experimental(selection, () =&gt; $createHeadingNode(tag) as any);&#10;      }&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {headingTags.map((tag) =&gt; (&#10;        &lt;ToolbarButton&#10;          onClick={() =&gt; {&#10;            onClick(tag);&#10;          }}&#10;          key={tag}&#10;          title={getTitle(tag)}&#10;          data-heading&#10;        &gt;&#10;          {tag.toUpperCase()}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;function ListToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const onClick = (tag: 'ol' | 'ul'): void =&gt; {&#10;    if (tag === 'ol') {&#10;      editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined);&#10;      return;&#10;    }&#10;    editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ol');&#10;        }}&#10;        title=&quot;Numaralı liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;OrderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ul');&#10;        }}&#10;        title=&quot;Madde işaretli liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;UnorderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export function ToolbarPlugin(): JSX.Element {&#10;  return (&#10;    &lt;Toolbar.Root className=&quot;toolbarRoot&quot;&gt;&#10;      &lt;TextFormatToolbarPlugin /&gt;&#10;      &lt;HeadingToolbarPlugin /&gt;&#10;      &lt;ListToolbarPlugin /&gt;&#10;      &lt;PageSectionVisibilityToolbar /&gt;&#10;    &lt;/Toolbar.Root&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $setBlocksType_experimental } from '@lexical/selection';&#10;import { $isRangeSelection, $getSelection, type TextFormatType } from 'lexical';&#10;import { $createHeadingNode } from '@lexical/rich-text';&#10;import { INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND } from '@lexical/list';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;import {&#10;  StrikethroughIcon,&#10;  FontBoldIcon,&#10;  FontItalicIcon,&#10;  UnderlineIcon,&#10;} from '@radix-ui/react-icons';&#10;import { OrderedListIcon, UnorderedListIcon } from './icons';&#10;import { PageSectionVisibilityToolbar } from './PageSectionVisibilityToolbar';&#10;&#10;&#10;interface ToolbarButtonProps {&#10;  className?: string;&#10;  onClick?: () =&gt; void;&#10;  title?: string;&#10;  children: React.ReactNode;&#10;  disabled?: boolean;&#10;}&#10;&#10;function ToolbarButton(props: ToolbarButtonProps): JSX.Element {&#10;  const { className, onClick, title, children, disabled, ...rest } = props;&#10;  return (&#10;    &lt;Toolbar.Button&#10;      className={`toolbarButton ${className ?? ''}`}&#10;      onClick={onClick}&#10;      title={title}&#10;      disabled={disabled}&#10;      {...rest}&#10;    &gt;&#10;      {children}&#10;    &lt;/Toolbar.Button&gt;&#10;  );&#10;}&#10;&#10;function TextFormatToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const getIcon = (format: TextFormatType): JSX.Element | null =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return &lt;FontBoldIcon /&gt;;&#10;      case 'italic':&#10;        return &lt;FontItalicIcon /&gt;;&#10;      case 'strikethrough':&#10;        return &lt;StrikethroughIcon /&gt;;&#10;      case 'underline':&#10;        return &lt;UnderlineIcon /&gt;;&#10;      default:&#10;        return null;&#10;    }&#10;  };&#10;&#10;  const getTitle = (format: TextFormatType): string =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return 'Kalın (Ctrl+B)';&#10;      case 'italic':&#10;        return 'İtalik (Ctrl+I)';&#10;      case 'underline':&#10;        return 'Alt çizgi (Ctrl+U)';&#10;      case 'strikethrough':&#10;        return 'Üstü çizili';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (format: TextFormatType): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        selection.formatText(format);&#10;      }&#10;    });&#10;  };&#10;&#10;  const supportedTextFormats: TextFormatType[] = ['bold', 'italic', 'underline', 'strikethrough'];&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {supportedTextFormats.map((format) =&gt; (&#10;        &lt;ToolbarButton&#10;          key={format}&#10;          onClick={() =&gt; {&#10;            onClick(format);&#10;          }}&#10;          title={getTitle(format)}&#10;          data-format&#10;        &gt;&#10;          {getIcon(format)}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;&#10;type HeadingTag = 'h1' | 'h2' | 'h3';&#10;function HeadingToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const headingTags: HeadingTag[] = ['h1', 'h2', 'h3'];&#10;&#10;  const getTitle = (tag: HeadingTag): string =&gt; {&#10;    switch (tag) {&#10;      case 'h1':&#10;        return 'Başlık 1';&#10;      case 'h2':&#10;        return 'Başlık 2';&#10;      case 'h3':&#10;        return 'Başlık 3';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (tag: HeadingTag): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        $setBlocksType_experimental(selection, () =&gt; $createHeadingNode(tag) as any);&#10;      }&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {headingTags.map((tag) =&gt; (&#10;        &lt;ToolbarButton&#10;          onClick={() =&gt; {&#10;            onClick(tag);&#10;          }}&#10;          key={tag}&#10;          title={getTitle(tag)}&#10;          data-heading&#10;        &gt;&#10;          {tag.toUpperCase()}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;function ListToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const onClick = (tag: 'ol' | 'ul'): void =&gt; {&#10;    if (tag === 'ol') {&#10;      editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined);&#10;      return;&#10;    }&#10;    editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ol');&#10;        }}&#10;        title=&quot;Numaralı liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;OrderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ul');&#10;        }}&#10;        title=&quot;Madde işaretli liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;UnorderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export function ToolbarPlugin(): JSX.Element {&#10;  return (&#10;    &lt;Toolbar.Root className=&quot;toolbarRoot&quot;&gt;&#10;      &lt;TextFormatToolbarPlugin /&gt;&#10;      &lt;HeadingToolbarPlugin /&gt;&#10;      &lt;ListToolbarPlugin /&gt;&#10;      &lt;PageSectionVisibilityToolbar /&gt;&#10;    &lt;/Toolbar.Root&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/playground/App.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/playground/App.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;&#10;function App() {&#10;&#10;  return (&#10;    &lt;&gt;&#10;    &lt;/&gt;&#10;  );&#10;}&#10;&#10;export default App;&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import Editor from '../components/editor/Editor';&#10;&#10;function App() {&#10;  return (&#10;    &lt;div style={{ minHeight: '100vh', background: '#f4f4f4' }}&gt;&#10;      &lt;Editor /&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>