<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/editor/EditModeContext.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/EditModeContext.tsx" />
              <option name="originalContent" value="import React, { createContext, useContext, useMemo } from 'react';&#10;&#10;export interface EditModeContextValue {&#10;  headerFooterEditMode: boolean;&#10;}&#10;&#10;const EditModeContext = createContext&lt;EditModeContextValue&gt;({ headerFooterEditMode: false });&#10;&#10;export function useEditModeContext(): EditModeContextValue {&#10;  return useContext(EditModeContext);&#10;}&#10;&#10;export function EditModeProvider({&#10;  value,&#10;  children&#10;}: {&#10;  value: EditModeContextValue;&#10;  children: React.ReactNode;&#10;}): JSX.Element {&#10;  const memo = useMemo(() =&gt; value, [value.headerFooterEditMode]);&#10;  return &lt;EditModeContext.Provider value={memo}&gt;{children}&lt;/EditModeContext.Provider&gt;;&#10;}&#10;" />
              <option name="updatedContent" value="import React, { createContext, useContext, useMemo } from 'react';&#10;&#10;export interface EditModeContextValue {&#10;  headerFooterEditMode: boolean;&#10;  setHeaderFooterEditMode?: (value: boolean) =&gt; void;&#10;}&#10;&#10;const EditModeContext = createContext&lt;EditModeContextValue&gt;({ headerFooterEditMode: false });&#10;&#10;export function useEditModeContext(): EditModeContextValue {&#10;  return useContext(EditModeContext);&#10;}&#10;&#10;export function EditModeProvider({&#10;  value,&#10;  children&#10;}: {&#10;  value: EditModeContextValue;&#10;  children: React.ReactNode;&#10;}): JSX.Element {&#10;  const memo = useMemo(() =&gt; value, [value.headerFooterEditMode, value.setHeaderFooterEditMode]);&#10;  return &lt;EditModeContext.Provider value={memo}&gt;{children}&lt;/EditModeContext.Provider&gt;;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/Editor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/Editor.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { ToolbarPlugin } from '../toolbar/Toolbar';&#10;import './styles.css';&#10;import { editorNodes } from './nodes';&#10;import { PageInitializerPlugin } from './plugins/PageInitializerPlugin';&#10;import { EditModeProvider } from './EditModeContext';&#10;import { ContentSelectAllPlugin } from './plugins/ContentSelectAllPlugin';&#10;import { PageAutoSplitPlugin } from './plugins/PageAutoSplitPlugin';&#10;import PageContentFlowPlugin from './plugins/PageContentFlowPlugin';&#10;import PageContentEditable from './PageContentEditable';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;function initialEditorState(): void {&#10;  // Initial state handled by PageInitializerPlugin&#10;}&#10;&#10;export default function Editor(): JSX.Element {&#10;  const [headerFooterEditMode, setHeaderFooterEditMode] = React.useState(false);&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    editorState: initialEditorState,&#10;    nodes: editorNodes&#10;  } as const;&#10;&#10;  // EditModeContext'i hem değer hem setter ile sağlayalım&#10;  const editModeContextValue = React.useMemo(&#10;    () =&gt; ({ headerFooterEditMode, setHeaderFooterEditMode }),&#10;    [headerFooterEditMode]&#10;  );&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-a4-wrapper&quot;&gt;&#10;      &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;        &lt;EditModeProvider value={editModeContextValue}&gt;&#10;          &lt;ToolbarPlugin&#10;            headerFooterEditMode={headerFooterEditMode}&#10;            setHeaderFooterEditMode={setHeaderFooterEditMode}&#10;          /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;PageContentEditable /&gt;}&#10;            placeholder={&lt;div className=&quot;editor-placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;PageInitializerPlugin /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;ContentSelectAllPlugin /&gt;&#10;          &lt;PageAutoSplitPlugin pageHeightMm={297} marginTopMm={20} marginBottomMm={20} /&gt;&#10;          &lt;PageContentFlowPlugin /&gt;&#10;        &lt;/EditModeProvider&gt;&#10;      &lt;/LexicalComposer&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { ToolbarPlugin } from '../toolbar/Toolbar';&#10;import './styles.css';&#10;import { editorNodes } from './nodes';&#10;import { PageInitializerPlugin } from './plugins/PageInitializerPlugin';&#10;import { EditModeProvider } from './EditModeContext';&#10;import { ContentSelectAllPlugin } from './plugins/ContentSelectAllPlugin';&#10;import { PageAutoSplitPlugin } from './plugins/PageAutoSplitPlugin';&#10;import PageContentFlowPlugin from './plugins/PageContentFlowPlugin';&#10;import PageContentEditable from './PageContentEditable';&#10;import { HeaderFooterSyncPlugin } from './plugins/HeaderFooterSyncPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;function initialEditorState(): void {&#10;  // Initial state handled by PageInitializerPlugin&#10;}&#10;&#10;export default function Editor(): JSX.Element {&#10;  const [headerFooterEditMode, setHeaderFooterEditMode] = React.useState(false);&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    editorState: initialEditorState,&#10;    nodes: editorNodes&#10;  } as const;&#10;&#10;  // EditModeContext'i hem değer hem setter ile sağlayalım&#10;  const editModeContextValue = React.useMemo(&#10;    () =&gt; ({ headerFooterEditMode, setHeaderFooterEditMode }),&#10;    [headerFooterEditMode]&#10;  );&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-a4-wrapper&quot;&gt;&#10;      &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;        &lt;EditModeProvider value={editModeContextValue}&gt;&#10;          &lt;ToolbarPlugin&#10;            headerFooterEditMode={headerFooterEditMode}&#10;            setHeaderFooterEditMode={setHeaderFooterEditMode}&#10;          /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;PageContentEditable /&gt;}&#10;            placeholder={&lt;div className=&quot;editor-placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;PageInitializerPlugin /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;ContentSelectAllPlugin /&gt;&#10;          &lt;PageAutoSplitPlugin pageHeightMm={297} marginTopMm={20} marginBottomMm={20} /&gt;&#10;          &lt;PageContentFlowPlugin /&gt;&#10;          {/* Header/Footer senkronizasyonu için plugin ekleniyor */}&#10;          &lt;HeaderFooterSyncPlugin /&gt;&#10;        &lt;/EditModeProvider&gt;&#10;      &lt;/LexicalComposer&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/PageContentEditable.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/PageContentEditable.tsx" />
              <option name="originalContent" value="import React from 'react';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { useEditModeContext } from './EditModeContext';&#10;import './styles.css';&#10;&#10;/**&#10; * Profesyonelce: Edit mode kontrolü ve tıklama davranışı burada yönetilir.&#10; * Görsel olarak da &quot;disabled&quot; efekti eklenir.&#10; */&#10;export default function PageContentEditable() {&#10;  const { headerFooterEditMode, setHeaderFooterEditMode } = useEditModeContext();&#10;&#10;  const handleClick = React.useCallback(() =&gt; {&#10;    if (headerFooterEditMode &amp;&amp; setHeaderFooterEditMode) {&#10;      setHeaderFooterEditMode(false);&#10;    }&#10;  }, [headerFooterEditMode, setHeaderFooterEditMode]);&#10;&#10;  return (&#10;    &lt;div onClick={handleClick}&gt;&#10;      &lt;ContentEditable contentEditable={!headerFooterEditMode} /&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import React from 'react';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { useEditModeContext } from './EditModeContext';&#10;import './styles.css';&#10;&#10;/**&#10; * Profesyonelce: Edit mode kontrolü ve tıklama davranışı burada yönetilir.&#10; * Görsel olarak da &quot;disabled&quot; efekti eklenir.&#10; */&#10;export default function PageContentEditable(): JSX.Element {&#10;  const { headerFooterEditMode, setHeaderFooterEditMode } = useEditModeContext();&#10;&#10;  const handleClick = React.useCallback(() =&gt; {&#10;    if (!!headerFooterEditMode &amp;&amp; !!setHeaderFooterEditMode) {&#10;      setHeaderFooterEditMode(false);&#10;    }&#10;  }, [headerFooterEditMode, setHeaderFooterEditMode]);&#10;&#10;  return (&#10;    &lt;div onClick={handleClick}&gt;&#10;      &lt;ContentEditable contentEditable={!headerFooterEditMode} /&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/context/EditModeContext.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/context/EditModeContext.tsx" />
              <option name="originalContent" value="import React, { createContext, useContext, useMemo } from 'react';&#10;&#10;export interface EditModeContextValue {&#10;  headerFooterEditMode: boolean;&#10;  setHeaderFooterEditMode?: (value: boolean) =&gt; void;&#10;}&#10;&#10;const EditModeContext = createContext&lt;EditModeContextValue&gt;({ headerFooterEditMode: false });&#10;&#10;export function useEditModeContext(): EditModeContextValue {&#10;  return useContext(EditModeContext);&#10;}&#10;&#10;export function EditModeProvider({&#10;  value,&#10;  children&#10;}: {&#10;  value: EditModeContextValue;&#10;  children: React.ReactNode;&#10;}): JSX.Element {&#10;  const memo = useMemo(() =&gt; value, [value.headerFooterEditMode, value.setHeaderFooterEditMode]);&#10;  return &lt;EditModeContext.Provider value={memo}&gt;{children}&lt;/EditModeContext.Provider&gt;;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * EditModeContext&#10; *&#10; * Bu context, editörde header/footer düzenleme modunun (headerFooterEditMode) yönetilmesini sağlar.&#10; *&#10; * Sağlanan değerler:&#10; * - headerFooterEditMode: Header/footer düzenleme modu açık mı?&#10; * - setHeaderFooterEditMode: Modu değiştiren fonksiyon (opsiyonel, zorunlu değil)&#10; *&#10; * Kullanım Senaryosu:&#10; * - Kullanıcı header/footer alanlarını düzenlemek istediğinde, bu mod aktif edilir.&#10; * - EditModeProvider ile context sağlanır, useEditModeContext ile erişilir.&#10; *&#10; * Notlar:&#10; * - Provider'a verilen value nesnesi memoize edilir, böylece gereksiz render'lar önlenir.&#10; */&#10;&#10;import React, { createContext, useContext, useMemo } from 'react';&#10;&#10;export interface EditModeContextValue {&#10;  headerFooterEditMode: boolean;&#10;  setHeaderFooterEditMode?: (value: boolean) =&gt; void;&#10;}&#10;&#10;const EditModeContext = createContext&lt;EditModeContextValue&gt;({ headerFooterEditMode: false });&#10;&#10;export function useEditModeContext(): EditModeContextValue {&#10;  return useContext(EditModeContext);&#10;}&#10;&#10;export function EditModeProvider({&#10;  value,&#10;  children&#10;}: {&#10;  value: EditModeContextValue;&#10;  children: React.ReactNode;&#10;}): JSX.Element {&#10;  const memo = useMemo(() =&gt; value, [value.headerFooterEditMode, value.setHeaderFooterEditMode]);&#10;  return &lt;EditModeContext.Provider value={memo}&gt;{children}&lt;/EditModeContext.Provider&gt;;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageContentNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageContentNode.tsx" />
              <option name="originalContent" value="import { ElementNode, type SerializedElementNode } from 'lexical';&#10;&#10;export type SerializedPageContentNode = SerializedElementNode &amp; {&#10;  type: 'page-content';&#10;  version: 1;&#10;};&#10;&#10;export class PageContentNode extends ElementNode {&#10;  /**&#10;   * Node tipini döndürür. (&quot;page-content&quot;)&#10;   */&#10;  static getType(): string {&#10;    return 'page-content';&#10;  }&#10;&#10;  /**&#10;   * Bu node'un klonunu oluşturur.&#10;   */&#10;  static clone(node: PageContentNode): PageContentNode {&#10;    return new PageContentNode(node.__key);&#10;  }&#10;&#10;  /**&#10;   * Anahtar ile yeni bir PageContentNode oluşturur.&#10;   */&#10;  constructor(key?: string) {&#10;    super(key);&#10;  }&#10;&#10;  /**&#10;   * Bu node'un silinmesini engeller.&#10;   */&#10;  remove(): void {&#10;    // Hiçbir şey yapma, silinemez&#10;  }&#10;&#10;  /**&#10;   * Bu node'un çocuklarının silinmesini engeller.&#10;   */&#10;  removeChild(): void {&#10;    // Hiçbir şey yapma, silinemez&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden div'i oluşturur.&#10;   */&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-content';&#10;    dom.setAttribute('data-lexical-node-key', this.getKey());&#10;    return dom;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageContentNode oluşturur.&#10;   */&#10;  static importJSON(serializedNode: SerializedPageContentNode): PageContentNode {&#10;    return new PageContentNode();&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   */&#10;  exportJSON(): SerializedPageContentNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-content',&#10;      version: 1&#10;    };&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ElementNode, type SerializedElementNode } from 'lexical';&#10;&#10;export type SerializedPageContentNode = SerializedElementNode &amp; {&#10;  type: 'page-content';&#10;  version: 1;&#10;};&#10;&#10;export class PageContentNode extends ElementNode {&#10;  static getType(): string {&#10;    return 'page-content';&#10;  }&#10;&#10;  static clone(node: PageContentNode): PageContentNode {&#10;    return new PageContentNode(node.__key);&#10;  }&#10;&#10;  // We need this constructor to forward the key to ElementNode for proper cloning behavior&#10;  // eslint-disable-next-line @typescript-eslint/no-useless-constructor&#10;  constructor(key?: string) {&#10;    super(key);&#10;  }&#10;&#10;  /**&#10;   * Bu node'un silinmesini engeller.&#10;   *&#10;   * Hiçbir şey yapmaz, böylece PageContentNode asla silinemez.&#10;   *&#10;   * Örneğin bir kullanıcı veya kod remove() çağırsa bile node yerinde kalır.&#10;   */&#10;  remove(): void {&#10;    // Hiçbir şey yapma, silinemez&#10;  }&#10;&#10;  /**&#10;   * Bu node'un çocuklarının silinmesini engeller.&#10;   *&#10;   * Hiçbir şey yapmaz, böylece PageContentNode'un çocukları da silinemez.&#10;   */&#10;  removeChild(): void {&#10;    // Hiçbir şey yapma, silinemez&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden div'i oluşturur.&#10;   *&#10;   * @returns 'a4-content' class'ına sahip bir div elementi döner.&#10;   *&#10;   * Not: data-lexical-node-key ile node'un anahtarı DOM'a eklenir.&#10;   */&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-content';&#10;    dom.setAttribute('data-lexical-node-key', this.getKey());&#10;    return dom;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   *&#10;   * @returns false (React veya Lexical bu node için DOM güncellemesi yapmaz)&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageContentNode oluşturur.&#10;   *&#10;   * @param serializedNode - Serileştirilmiş PageContentNode nesnesi&#10;   * @returns Yeni bir PageContentNode örneği&#10;   */&#10;  static importJSON(serializedNode: SerializedPageContentNode): PageContentNode {&#10;    return new PageContentNode();&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   *&#10;   * @returns PageContentNode'un serileştirilmiş hali&#10;   */&#10;  exportJSON(): SerializedPageContentNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page-content',&#10;      version: 1&#10;    };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageFooterNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageFooterNode.tsx" />
              <option name="originalContent" value="import {&#10;  DecoratorNode,&#10;  type SerializedElementNode,&#10;  type EditorConfig,&#10;  type Spread,&#10;  $getNodeByKey,&#10;  type NodeKey,&#10;  type LexicalEditor&#10;} from 'lexical';&#10;import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEditModeContext } from '../EditModeContext';&#10;&#10;export type SerializedPageFooterNode = Spread&lt;&#10;  { type: 'page-footer'; version: 1; text: string; visible: boolean },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;// PageFooterNode: Sayfa alt bilgisini (footer) temsil eden Lexical DecoratorNode sınıfı.&#10;// Footer'ın görünürlüğü ve metni yönetilebilir. DOM'da özel bir alan olarak gösterilir.&#10;// decorate fonksiyonu ile React bileşeni olarak düzenlenebilir.&#10;export class PageFooterNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  __text: string;&#10;  __visible: boolean;&#10;&#10;  /**&#10;   * Node tipini döndürür. (&quot;page-footer&quot;)&#10;   */&#10;  static getType(): string {&#10;    return 'page-footer';&#10;  }&#10;&#10;  /**&#10;   * Bu node'un klonunu oluşturur.&#10;   */&#10;  static clone(node: PageFooterNode): PageFooterNode {&#10;    return new PageFooterNode(node.__text, node.__key, node.__visible);&#10;  }&#10;&#10;  /**&#10;   * Metin ve görünürlük ile yeni bir PageFooterNode oluşturur.&#10;   */&#10;  constructor(text = '', key?: string, visible = false) {&#10;    super(key);&#10;    this.__text = text;&#10;    this.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Footer'ın görünürlüğünü ayarlar.&#10;   */&#10;  setVisible(visible: boolean): void {&#10;    const writable = this.getWritable();&#10;    writable.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Footer'ın görünür olup olmadığını döndürür.&#10;   */&#10;  isVisible(): boolean {&#10;    return this.__visible;&#10;  }&#10;&#10;  /**&#10;   * Footer metnini ayarlar.&#10;   */&#10;  setText(text: string): void {&#10;    const writable = this.getWritable();&#10;    writable.__text = text;&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden span oluşturur.&#10;   */&#10;  createDOM(_config: EditorConfig): HTMLElement {&#10;    const span = document.createElement('span');&#10;    return span;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageFooterNode oluşturur.&#10;   */&#10;  static importJSON(serializedNode: SerializedPageFooterNode): PageFooterNode {&#10;    const node = new PageFooterNode(serializedNode.text, undefined, serializedNode.visible);&#10;    return node;&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   */&#10;  exportJSON(): SerializedPageFooterNode {&#10;    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions&#10;    const json = {&#10;      ...super.exportJSON(),&#10;      type: 'page-footer',&#10;      version: 1,&#10;      text: this.__text,&#10;      visible: this.__visible&#10;    } as SerializedPageFooterNode;&#10;    return json;&#10;  }&#10;&#10;  /**&#10;   * Footer'ı React bileşeni olarak döndürür.&#10;   */&#10;  decorate(_editor: LexicalEditor, _config: EditorConfig): JSX.Element {&#10;    return this.__visible ? &lt;FooterEditable text={this.__text} nodeKey={this.getKey()} /&gt; : &lt;&gt;&lt;/&gt;;&#10;  }&#10;}&#10;&#10;/**&#10; * FooterEditable: Footer alanını düzenlenebilir olarak gösteren React bileşeni.&#10; * Sadece headerFooterEditMode açıkken düzenlenebilir olur.&#10; */&#10;function FooterEditable({ text, nodeKey }: { text: string; nodeKey: NodeKey }): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const { headerFooterEditMode } = useEditModeContext();&#10;  const divRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;  React.useEffect(() =&gt; {&#10;    const el = divRef.current;&#10;    if (el !== null &amp;&amp; el.innerText !== text) {&#10;      el.innerText = text;&#10;    }&#10;  }, [text]);&#10;&#10;  const commit = React.useCallback(&#10;    (newText: string) =&gt; {&#10;      editor.update(() =&gt; {&#10;        const node = $getNodeByKey(nodeKey);&#10;        if (node instanceof PageFooterNode) {&#10;          node.setText(newText);&#10;        }&#10;      });&#10;    },&#10;    [editor, nodeKey]&#10;  );&#10;&#10;  const handleInput = React.useCallback(&#10;    (e: React.FormEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;      const newText = (e.target as HTMLDivElement).innerText;&#10;      commit(newText);&#10;    },&#10;    [commit]&#10;  );&#10;&#10;  const handleKeyDown = React.useCallback((e: React.KeyboardEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    if (e.ctrlKey &amp;&amp; (e.key === 'a' || e.key === 'A')) {&#10;      e.preventDefault();&#10;      const el = divRef.current;&#10;      if (el !== null) {&#10;        const range = document.createRange();&#10;        range.selectNodeContents(el);&#10;        const sel = window.getSelection();&#10;        if (sel !== null) {&#10;          sel.removeAllRanges();&#10;          sel.addRange(range);&#10;        }&#10;      }&#10;    }&#10;  }, []);&#10;&#10;  return (&#10;    &lt;div&#10;      ref={divRef}&#10;      className=&quot;a4-footer&quot;&#10;      contentEditable={headerFooterEditMode}&#10;      suppressContentEditableWarning&#10;      onInput={handleInput}&#10;      onKeyDown={handleKeyDown}&#10;      data-node-key={nodeKey}&#10;      data-lexical-node-key={nodeKey}&#10;      style={{ minHeight: '32px', outline: headerFooterEditMode ? '2px solid #1976d2' : 'none' }}&#10;    /&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import {&#10;  DecoratorNode,&#10;  type SerializedElementNode,&#10;  type EditorConfig,&#10;  type Spread,&#10;  $getNodeByKey,&#10;  type NodeKey,&#10;  type LexicalEditor&#10;} from 'lexical';&#10;import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEditModeContext } from '../EditModeContext';&#10;&#10;export type SerializedPageFooterNode = Spread&lt;&#10;  { type: 'page-footer'; version: 1; text: string; visible: boolean },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;// PageFooterNode: Sayfa alt bilgisini (footer) temsil eden Lexical DecoratorNode sınıfı.&#10;// Footer'ın görünürlüğü ve metni yönetilebilir. DOM'da özel bir alan olarak gösterilir.&#10;// decorate fonksiyonu ile React bileşeni olarak düzenlenebilir.&#10;export class PageFooterNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  __text: string;&#10;  __visible: boolean;&#10;&#10;  /**&#10;   * Node tipini döndürür. (&quot;page-footer&quot;)&#10;   */&#10;  static getType(): string {&#10;    return 'page-footer';&#10;  }&#10;&#10;  /**&#10;   * Bu node'un klonunu oluşturur.&#10;   */&#10;  static clone(node: PageFooterNode): PageFooterNode {&#10;    return new PageFooterNode(node.__text, node.__key, node.__visible);&#10;  }&#10;&#10;  /**&#10;   * Metin ve görünürlük ile yeni bir PageFooterNode oluşturur.&#10;   *&#10;   * @param text - Footer'da gösterilecek metin&#10;   * @param key - Lexical node anahtarı (opsiyonel)&#10;   * @param visible - Footer'ın görünür olup olmayacağı (varsayılan: false)&#10;   */&#10;  constructor(text = '', key?: string, visible = false) {&#10;    super(key);&#10;    this.__text = text;&#10;    this.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Footer'ın görünürlüğünü ayarlar.&#10;   *&#10;   * @param visible - Footer'ın görünür olup olmayacağını belirten boolean değer&#10;   *&#10;   * Not: getWritable ile node'un güncellenebilir kopyası alınır.&#10;   */&#10;  setVisible(visible: boolean): void {&#10;    // getWritable ile node'un güncellenebilir kopyasını alıyoruz.&#10;    // Bu sayede immutable veri modelinde değişiklik yapabiliyoruz.&#10;    const writable = this.getWritable();&#10;    writable.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Footer'ın görünür olup olmadığını döndürür.&#10;   *&#10;   * @returns true ise footer görünür, false ise gizlidir.&#10;   */&#10;  isVisible(): boolean {&#10;    return this.__visible;&#10;  }&#10;&#10;  /**&#10;   * Footer metnini ayarlar.&#10;   *&#10;   * @param text - Footer'da gösterilecek yeni metin&#10;   *&#10;   * Not: getWritable ile node'un güncellenebilir kopyası alınır.&#10;   */&#10;  setText(text: string): void {&#10;    // getWritable ile node'un güncellenebilir kopyasını alıyoruz.&#10;    // Bu sayede immutable veri modelinde değişiklik yapabiliyoruz.&#10;    const writable = this.getWritable();&#10;    writable.__text = text;&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden span oluşturur.&#10;   *&#10;   * @returns Boş bir span elementi (React ile doldurulacak)&#10;   */&#10;  createDOM(_config: EditorConfig): HTMLElement {&#10;    // DOM'da footer için bir span oluşturuyoruz.&#10;    // React, decorate fonksiyonu ile içeriği yönetecek.&#10;    const span = document.createElement('span');&#10;    return span;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageFooterNode oluşturur.&#10;   */&#10;  static importJSON(serializedNode: SerializedPageFooterNode): PageFooterNode {&#10;    const node = new PageFooterNode(serializedNode.text, undefined, serializedNode.visible);&#10;    return node;&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   */&#10;  exportJSON(): SerializedPageFooterNode {&#10;    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions&#10;    const json = {&#10;      ...super.exportJSON(),&#10;      type: 'page-footer',&#10;      version: 1,&#10;      text: this.__text,&#10;      visible: this.__visible&#10;    } as SerializedPageFooterNode;&#10;    return json;&#10;  }&#10;&#10;  /**&#10;   * Footer'ı React bileşeni olarak döndürür.&#10;   *&#10;   * @returns Eğer görünürse FooterEditable bileşeni, değilse boş bir fragment döner.&#10;   */&#10;  decorate(_editor: LexicalEditor, _config: EditorConfig): JSX.Element {&#10;    // Footer görünürse düzenlenebilir alanı göster, değilse boş döndür.&#10;    return this.__visible ? &lt;FooterEditable text={this.__text} nodeKey={this.getKey()} /&gt; : &lt;&gt;&lt;/&gt;;&#10;  }&#10;}&#10;&#10;/**&#10; * FooterEditable: Footer alanını düzenlenebilir olarak gösteren React bileşeni.&#10; * Sadece headerFooterEditMode açıkken düzenlenebilir olur.&#10; *&#10; * @param text - Footer'da gösterilecek metin&#10; * @param nodeKey - Lexical node anahtarı&#10; * @returns Düzenlenebilir bir div elementi&#10; *&#10; * Detaylar:&#10; * - onInput ile metin değişikliği anında node'a kaydedilir.&#10; * - onKeyDown ile Ctrl+A kısayolu sadece bu alanda çalışır.&#10; * - headerFooterEditMode true ise alan düzenlenebilir olur.&#10; */&#10;function FooterEditable({ text, nodeKey }: { text: string; nodeKey: NodeKey }): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const { headerFooterEditMode } = useEditModeContext();&#10;  const divRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;  React.useEffect(() =&gt; {&#10;    // DOM'daki div'in içeriğini güncel metinle eşitliyoruz.&#10;    // Eğer dışarıdan gelen text değişirse, div'in içeriği de güncellenir.&#10;    const el = divRef.current;&#10;    if (el !== null &amp;&amp; el.innerText !== text) {&#10;      el.innerText = text;&#10;    }&#10;  }, [text]);&#10;&#10;  const commit = React.useCallback(&#10;    (newText: string) =&gt; {&#10;      // Kullanıcı metni değiştirdiğinde, bu değişikliği Lexical node'a kaydediyoruz.&#10;      // editor.update ile Lexical'ın immutable veri modelinde güncelleme yapıyoruz.&#10;      editor.update(() =&gt; {&#10;        const node = $getNodeByKey(nodeKey);&#10;        if (node instanceof PageFooterNode) {&#10;          node.setText(newText);&#10;        }&#10;      });&#10;    },&#10;    [editor, nodeKey]&#10;  );&#10;&#10;  const handleInput = React.useCallback(&#10;    (e: React.FormEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;      // Kullanıcı div'e yazdıkça, yeni metni alıp commit fonksiyonuna iletiyoruz.&#10;      const newText = (e.target as HTMLDivElement).innerText;&#10;      commit(newText);&#10;    },&#10;    [commit]&#10;  );&#10;&#10;  const handleKeyDown = React.useCallback((e: React.KeyboardEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    // Ctrl+A ile sadece bu div içindeki tüm metni seçebilmek için özel bir kısayol ekliyoruz.&#10;    if (e.ctrlKey &amp;&amp; (e.key === 'a' || e.key === 'A')) {&#10;      e.preventDefault();&#10;      const el = divRef.current;&#10;      if (el !== null) {&#10;        const range = document.createRange();&#10;        range.selectNodeContents(el);&#10;        const sel = window.getSelection();&#10;        if (sel !== null) {&#10;          sel.removeAllRanges();&#10;          sel.addRange(range);&#10;        }&#10;      }&#10;    }&#10;  }, []);&#10;&#10;  return (&#10;    &lt;div&#10;      ref={divRef}&#10;      className=&quot;a4-footer&quot;&#10;      contentEditable={headerFooterEditMode}&#10;      suppressContentEditableWarning&#10;      onInput={handleInput}&#10;      onKeyDown={handleKeyDown}&#10;      data-node-key={nodeKey}&#10;      data-lexical-node-key={nodeKey}&#10;      style={{ minHeight: '32px', outline: headerFooterEditMode ? '2px solid #1976d2' : 'none' }}&#10;    /&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageHeaderNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageHeaderNode.tsx" />
              <option name="originalContent" value="import {&#10;  DecoratorNode,&#10;  type SerializedElementNode,&#10;  type EditorConfig,&#10;  type Spread,&#10;  $getNodeByKey,&#10;  type NodeKey,&#10;  type LexicalEditor&#10;} from 'lexical';&#10;import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEditModeContext } from '../EditModeContext';&#10;&#10;export type SerializedPageHeaderNode = Spread&lt;&#10;  { type: 'page-header'; version: 1; text: string; visible: boolean },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;// PageHeaderNode: Sayfa başlığını (header) temsil eden Lexical DecoratorNode sınıfı.&#10;// Header'ın görünürlüğü ve metni yönetilebilir. DOM'da özel bir alan olarak gösterilir.&#10;// decorate fonksiyonu ile React bileşeni olarak düzenlenebilir.&#10;export class PageHeaderNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  __text: string;&#10;  __visible: boolean;&#10;&#10;  /**&#10;   * Node tipini döndürür. (&quot;page-header&quot;)&#10;   */&#10;  static getType(): string {&#10;    return 'page-header';&#10;  }&#10;&#10;  /**&#10;   * Bu node'un klonunu oluşturur.&#10;   */&#10;  static clone(node: PageHeaderNode): PageHeaderNode {&#10;    return new PageHeaderNode(node.__text, node.__key, node.__visible);&#10;  }&#10;&#10;  /**&#10;   * Metin ve görünürlük ile yeni bir PageHeaderNode oluşturur.&#10;   */&#10;  constructor(text = '', key?: string, visible = false) {&#10;    super(key);&#10;    this.__text = text;&#10;    this.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Header'ın görünürlüğünü ayarlar.&#10;   */&#10;  setVisible(visible: boolean): void {&#10;    const writable = this.getWritable();&#10;    writable.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Header'ın görünür olup olmadığını döndürür.&#10;   */&#10;  isVisible(): boolean {&#10;    return this.__visible;&#10;  }&#10;&#10;  /**&#10;   * Header metnini ayarlar.&#10;   */&#10;  setText(text: string): void {&#10;    const writable = this.getWritable();&#10;    writable.__text = text;&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden span oluşturur.&#10;   */&#10;  createDOM(_config: EditorConfig): HTMLElement {&#10;    const span = document.createElement('span');&#10;    // React will manage content via decorate&#10;    return span;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageHeaderNode oluşturur.&#10;   */&#10;  static importJSON(serializedNode: SerializedPageHeaderNode): PageHeaderNode {&#10;    const node = new PageHeaderNode(serializedNode.text, undefined, serializedNode.visible);&#10;    return node;&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   */&#10;  exportJSON(): SerializedPageHeaderNode {&#10;    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions&#10;    const json = {&#10;      ...super.exportJSON(),&#10;      type: 'page-header',&#10;      version: 1,&#10;      text: this.__text,&#10;      visible: this.__visible&#10;    } as SerializedPageHeaderNode;&#10;    return json;&#10;  }&#10;&#10;  /**&#10;   * Header'ı React bileşeni olarak döndürür.&#10;   */&#10;  decorate(_editor: LexicalEditor, _config: EditorConfig): JSX.Element {&#10;    // When not visible, render empty placeholder to satisfy return type&#10;    return this.__visible ? &lt;HeaderEditable text={this.__text} nodeKey={this.getKey()} /&gt; : &lt;&gt;&lt;/&gt;;&#10;  }&#10;}&#10;&#10;/**&#10; * HeaderEditable: Header alanını düzenlenebilir olarak gösteren React bileşeni.&#10; * Sadece headerFooterEditMode açıkken düzenlenebilir olur.&#10; */&#10;function HeaderEditable({ text, nodeKey }: { text: string; nodeKey: NodeKey }): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const { headerFooterEditMode } = useEditModeContext();&#10;  const divRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;  React.useEffect(() =&gt; {&#10;    const el = divRef.current;&#10;    if (el !== null &amp;&amp; el.innerText !== text) {&#10;      el.innerText = text;&#10;    }&#10;  }, [text]);&#10;&#10;  const commit = React.useCallback(&#10;    (newText: string) =&gt; {&#10;      editor.update(() =&gt; {&#10;        const node = $getNodeByKey(nodeKey);&#10;        if (node instanceof PageHeaderNode) {&#10;          node.setText(newText);&#10;        }&#10;      });&#10;    },&#10;    [editor, nodeKey]&#10;  );&#10;&#10;  const handleInput = React.useCallback(&#10;    (e: React.FormEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;      const newText = (e.target as HTMLDivElement).innerText;&#10;      commit(newText);&#10;    },&#10;    [commit]&#10;  );&#10;&#10;  const handleKeyDown = React.useCallback((e: React.KeyboardEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    if (e.ctrlKey &amp;&amp; (e.key === 'a' || e.key === 'A')) {&#10;      e.preventDefault();&#10;      const el = divRef.current;&#10;      if (el !== null) {&#10;        const range = document.createRange();&#10;        range.selectNodeContents(el);&#10;        const sel = window.getSelection();&#10;        if (sel !== null) {&#10;          sel.removeAllRanges();&#10;          sel.addRange(range);&#10;        }&#10;      }&#10;    }&#10;  }, []);&#10;&#10;  return (&#10;    &lt;div&#10;      ref={divRef}&#10;      className=&quot;a4-header&quot;&#10;      contentEditable={headerFooterEditMode}&#10;      suppressContentEditableWarning&#10;      onInput={handleInput}&#10;      onKeyDown={handleKeyDown}&#10;      data-node-key={nodeKey}&#10;      data-lexical-node-key={nodeKey}&#10;      style={{ minHeight: '32px', outline: headerFooterEditMode ? '2px solid #1976d2' : 'none' }}&#10;    /&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import {&#10;  DecoratorNode,&#10;  type SerializedElementNode,&#10;  type EditorConfig,&#10;  type Spread,&#10;  $getNodeByKey,&#10;  type NodeKey,&#10;  type LexicalEditor&#10;} from 'lexical';&#10;import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEditModeContext } from '../EditModeContext';&#10;&#10;export type SerializedPageHeaderNode = Spread&lt;&#10;  { type: 'page-header'; version: 1; text: string; visible: boolean },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;// PageHeaderNode: Sayfa başlığını (header) temsil eden Lexical DecoratorNode sınıfı.&#10;// Header'ın görünürlüğü ve metni yönetilebilir. DOM'da özel bir alan olarak gösterilir.&#10;// decorate fonksiyonu ile React bileşeni olarak düzenlenebilir.&#10;export class PageHeaderNode extends DecoratorNode&lt;JSX.Element&gt; {&#10;  __text: string;&#10;  __visible: boolean;&#10;&#10;  /**&#10;   * Node tipini döndürür. (&quot;page-header&quot;)&#10;   */&#10;  static getType(): string {&#10;    return 'page-header';&#10;  }&#10;&#10;  /**&#10;   * Bu node'un klonunu oluşturur.&#10;   */&#10;  static clone(node: PageHeaderNode): PageHeaderNode {&#10;    return new PageHeaderNode(node.__text, node.__key, node.__visible);&#10;  }&#10;&#10;  /**&#10;   * Metin ve görünürlük ile yeni bir PageHeaderNode oluşturur.&#10;   *&#10;   * @param text - Header'da gösterilecek metin&#10;   * @param key - Lexical node anahtarı (opsiyonel)&#10;   * @param visible - Header'ın görünür olup olmayacağı (varsayılan: false)&#10;   */&#10;  constructor(text = '', key?: string, visible = false) {&#10;    super(key);&#10;    this.__text = text;&#10;    this.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Header'ın görünürlüğünü ayarlar.&#10;   *&#10;   * @param visible - Header'ın görünür olup olmayacağını belirten boolean değer&#10;   *&#10;   * Not: getWritable ile node'un güncellenebilir kopyası alınır.&#10;   */&#10;  setVisible(visible: boolean): void {&#10;    // getWritable ile node'un güncellenebilir kopyasını alıyoruz.&#10;    // Bu sayede immutable veri modelinde değişiklik yapabiliyoruz.&#10;    const writable = this.getWritable();&#10;    writable.__visible = visible;&#10;  }&#10;&#10;  /**&#10;   * Header'ın görünür olup olmadığını döndürür.&#10;   *&#10;   * @returns true ise header görünür, false ise gizlidir.&#10;   */&#10;  isVisible(): boolean {&#10;    return this.__visible;&#10;  }&#10;&#10;  /**&#10;   * Header metnini ayarlar.&#10;   *&#10;   * @param text - Header'da gösterilecek yeni metin&#10;   *&#10;   * Not: getWritable ile node'un güncellenebilir kopyası alınır.&#10;   */&#10;  setText(text: string): void {&#10;    // getWritable ile node'un güncellenebilir kopyasını alıyoruz.&#10;    // Bu sayede immutable veri modelinde değişiklik yapabiliyoruz.&#10;    const writable = this.getWritable();&#10;    writable.__text = text;&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden span oluşturur.&#10;   *&#10;   * @returns Boş bir span elementi (React ile doldurulacak)&#10;   */&#10;  createDOM(_config: EditorConfig): HTMLElement {&#10;    // DOM'da header için bir span oluşturuyoruz.&#10;    // React, decorate fonksiyonu ile içeriği yönetecek.&#10;    const span = document.createElement('span');&#10;    return span;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageHeaderNode oluşturur.&#10;   */&#10;  static importJSON(serializedNode: SerializedPageHeaderNode): PageHeaderNode {&#10;    const node = new PageHeaderNode(serializedNode.text, undefined, serializedNode.visible);&#10;    return node;&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   */&#10;  exportJSON(): SerializedPageHeaderNode {&#10;    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions&#10;    const json = {&#10;      ...super.exportJSON(),&#10;      type: 'page-header',&#10;      version: 1,&#10;      text: this.__text,&#10;      visible: this.__visible&#10;    } as SerializedPageHeaderNode;&#10;    return json;&#10;  }&#10;&#10;  /**&#10;   * Header'ı React bileşeni olarak döndürür.&#10;   *&#10;   * @returns Eğer görünürse HeaderEditable bileşeni, değilse boş bir fragment döner.&#10;   */&#10;  decorate(_editor: LexicalEditor, _config: EditorConfig): JSX.Element {&#10;    // Header görünürse düzenlenebilir alanı göster, değilse boş döndür.&#10;    return this.__visible ? &lt;HeaderEditable text={this.__text} nodeKey={this.getKey()} /&gt; : &lt;&gt;&lt;/&gt;;&#10;  }&#10;}&#10;&#10;/**&#10; * HeaderEditable: Header alanını düzenlenebilir olarak gösteren React bileşeni.&#10; * Sadece headerFooterEditMode açıkken düzenlenebilir olur.&#10; *&#10; * @param text - Header'da gösterilecek metin&#10; * @param nodeKey - Lexical node anahtarı&#10; * @returns Düzenlenebilir bir div elementi&#10; *&#10; * Detaylar:&#10; * - onInput ile metin değişikliği anında node'a kaydedilir.&#10; * - onKeyDown ile Ctrl+A kısayolu sadece bu alanda çalışır.&#10; * - headerFooterEditMode true ise alan düzenlenebilir olur.&#10; */&#10;function HeaderEditable({ text, nodeKey }: { text: string; nodeKey: NodeKey }): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const { headerFooterEditMode } = useEditModeContext();&#10;  const divRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;  React.useEffect(() =&gt; {&#10;    // DOM'daki div'in içeriğini güncel metinle eşitliyoruz.&#10;    // Eğer dışarıdan gelen text değişirse, div'in içeriği de güncellenir.&#10;    const el = divRef.current;&#10;    if (el !== null &amp;&amp; el.innerText !== text) {&#10;      el.innerText = text;&#10;    }&#10;  }, [text]);&#10;&#10;  const commit = React.useCallback(&#10;    (newText: string) =&gt; {&#10;      // Kullanıcı metni değiştirdiğinde, bu değişikliği Lexical node'a kaydediyoruz.&#10;      // editor.update ile Lexical'ın immutable veri modelinde güncelleme yapıyoruz.&#10;      editor.update(() =&gt; {&#10;        const node = $getNodeByKey(nodeKey);&#10;        if (node instanceof PageHeaderNode) {&#10;          node.setText(newText);&#10;        }&#10;      });&#10;    },&#10;    [editor, nodeKey]&#10;  );&#10;&#10;  const handleInput = React.useCallback(&#10;    (e: React.FormEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;      // Kullanıcı div'e yazdıkça, yeni metni alıp commit fonksiyonuna iletiyoruz.&#10;      const newText = (e.target as HTMLDivElement).innerText;&#10;      commit(newText);&#10;    },&#10;    [commit]&#10;  );&#10;&#10;  const handleKeyDown = React.useCallback((e: React.KeyboardEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    // Ctrl+A ile sadece bu div içindeki tüm metni seçebilmek için özel bir kısayol ekliyoruz.&#10;    if (e.ctrlKey &amp;&amp; (e.key === 'a' || e.key === 'A')) {&#10;      e.preventDefault();&#10;      const el = divRef.current;&#10;      if (el !== null) {&#10;        const range = document.createRange();&#10;        range.selectNodeContents(el);&#10;        const sel = window.getSelection();&#10;        if (sel !== null) {&#10;          sel.removeAllRanges();&#10;          sel.addRange(range);&#10;        }&#10;      }&#10;    }&#10;  }, []);&#10;&#10;  return (&#10;    &lt;div&#10;      ref={divRef}&#10;      className=&quot;a4-header&quot;&#10;      contentEditable={headerFooterEditMode}&#10;      suppressContentEditableWarning&#10;      onInput={handleInput}&#10;      onKeyDown={handleKeyDown}&#10;      data-node-key={nodeKey}&#10;      data-lexical-node-key={nodeKey}&#10;      style={{ minHeight: '32px', outline: headerFooterEditMode ? '2px solid #1976d2' : 'none' }}&#10;    /&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/PageNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/PageNode.tsx" />
              <option name="originalContent" value="import { ElementNode, type SerializedElementNode, type LexicalNode } from 'lexical';&#10;import { PageHeaderNode } from './PageHeaderNode';&#10;import { PageFooterNode } from './PageFooterNode';&#10;import { PageContentNode } from './PageContentNode';&#10;&#10;export function $createPageNode(): PageNode {&#10;  return new PageNode({});&#10;}&#10;&#10;export function $isPageNode(node: LexicalNode | null | undefined): node is PageNode {&#10;  return node instanceof PageNode;&#10;}&#10;&#10;export type SerializedPageNode = {&#10;  type: 'page';&#10;  version: 1;&#10;} &amp; SerializedElementNode;&#10;&#10;// PageNode: Bir sayfanın tamamını temsil eden Lexical ElementNode sınıfı.&#10;// Her sayfa, header, content ve footer node'larını çocuk olarak içerir.&#10;// ensureHeaderFooterContentChildren ile bu çocukların varlığı ve sırası garanti edilir.&#10;export class PageNode extends ElementNode {&#10;  /**&#10;   * Node tipini döndürür. (&quot;page&quot;)&#10;   */&#10;  static getType(): string {&#10;    return 'page';&#10;  }&#10;&#10;  /**&#10;   * Bu node'un klonunu oluşturur.&#10;   */&#10;  static clone(node: PageNode): PageNode {&#10;    return new PageNode({ key: node.__key });&#10;  }&#10;&#10;  /**&#10;   * Yeni bir PageNode oluşturur.&#10;   */&#10;  constructor({ key }: { key?: string }) {&#10;    super(key);&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden div'i oluşturur.&#10;   */&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-page';&#10;    dom.style.display = 'flex';&#10;    dom.style.flexDirection = 'column';&#10;    // Use px to be consistent with runtime measurements (96dpi approx)&#10;    dom.style.width = '794px'; // 210mm ~ 8.27in * 96&#10;    dom.style.height = '1122px'; // 297mm ~ 11.69in * 96&#10;    dom.style.background = '#fff';&#10;    dom.style.position = 'relative';&#10;    dom.style.overflow = 'hidden';&#10;    return dom;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageNode oluşturur.&#10;   */&#10;  static importJSON(serializedNode: SerializedPageNode): PageNode {&#10;    const node = new PageNode({});&#10;    return node;&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   */&#10;  exportJSON(): SerializedPageNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page',&#10;      version: 1&#10;    };&#10;  }&#10;&#10;  /**&#10;   * Header, content ve footer node'larının varlığını ve sırasını garanti eder.&#10;   */&#10;  ensureHeaderFooterContentChildren(): void {&#10;    // Sıralama: header -&gt; content -&gt; footer (section her zaman ortada)&#10;    let header = this.getChildren().find((child) =&gt; child.getType() === 'page-header');&#10;    let content = this.getChildren().find((child) =&gt; child.getType() === 'page-content');&#10;    let footer = this.getChildren().find((child) =&gt; child.getType() === 'page-footer');&#10;    if (header == null) header = new PageHeaderNode('', undefined, false);&#10;    if (content == null) content = new PageContentNode();&#10;    if (footer == null) footer = new PageFooterNode('', undefined, false);&#10;    // Tüm çocukları kaldır ve doğru sırayla ekle&#10;    this.getChildren().forEach((child) =&gt; {&#10;      child.remove();&#10;    });&#10;    this.append(header);&#10;    this.append(content);&#10;    this.append(footer);&#10;  }&#10;&#10;  /**&#10;   * Başlangıçta header, content ve footer ekler.&#10;   */&#10;  appendInitialChildren(): void {&#10;    this.ensureHeaderFooterContentChildren();&#10;  }&#10;&#10;  /**&#10;   * Header node'unu döndürür.&#10;   */&#10;  getHeaderNode(): PageHeaderNode | undefined {&#10;    return this.getChildren().find((child) =&gt; child.getType() === 'page-header') as PageHeaderNode;&#10;  }&#10;&#10;  /**&#10;   * Footer node'unu döndürür.&#10;   */&#10;  getFooterNode(): PageFooterNode | undefined {&#10;    return this.getChildren().find((child) =&gt; child.getType() === 'page-footer') as PageFooterNode;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ElementNode, type SerializedElementNode, type LexicalNode } from 'lexical';&#10;import { PageHeaderNode } from './PageHeaderNode';&#10;import { PageFooterNode } from './PageFooterNode';&#10;import { PageContentNode } from './PageContentNode';&#10;&#10;export function $createPageNode(): PageNode {&#10;  return new PageNode({});&#10;}&#10;&#10;export function $isPageNode(node: LexicalNode | null | undefined): node is PageNode {&#10;  return node instanceof PageNode;&#10;}&#10;&#10;export type SerializedPageNode = {&#10;  type: 'page';&#10;  version: 1;&#10;} &amp; SerializedElementNode;&#10;&#10;// PageNode: Bir sayfanın tamamını temsil eden Lexical ElementNode sınıfı.&#10;// Her sayfa, header, content ve footer node'larını çocuk olarak içerir.&#10;// ensureHeaderFooterContentChildren ile bu çocukların varlığı ve sırası garanti edilir.&#10;export class PageNode extends ElementNode {&#10;  /**&#10;   * Node tipini döndürür. (&quot;page&quot;)&#10;   */&#10;  static getType(): string {&#10;    return 'page';&#10;  }&#10;&#10;  /**&#10;   * Bu node'un klonunu oluşturur.&#10;   */&#10;  static clone(node: PageNode): PageNode {&#10;    return new PageNode({ key: node.__key });&#10;  }&#10;&#10;  /**&#10;   * Yeni bir PageNode oluşturur.&#10;   */&#10;  constructor({ key }: { key?: string }) {&#10;    super(key);&#10;  }&#10;&#10;  /**&#10;   * DOM'da bu node'u temsil eden div'i oluşturur.&#10;   */&#10;  createDOM(): HTMLElement {&#10;    const dom = document.createElement('div');&#10;    dom.className = 'a4-page';&#10;    dom.style.display = 'flex';&#10;    dom.style.flexDirection = 'column';&#10;    // Use px to be consistent with runtime measurements (96dpi approx)&#10;    dom.style.width = '794px'; // 210mm ~ 8.27in * 96&#10;    dom.style.height = '1122px'; // 297mm ~ 11.69in * 96&#10;    dom.style.background = '#fff';&#10;    dom.style.position = 'relative';&#10;    dom.style.overflow = 'hidden';&#10;    return dom;&#10;  }&#10;&#10;  /**&#10;   * DOM güncellemesi gerektirmez.&#10;   */&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  /**&#10;   * JSON'dan PageNode oluşturur.&#10;   */&#10;  static importJSON(serializedNode: SerializedPageNode): PageNode {&#10;    const node = new PageNode({});&#10;    return node;&#10;  }&#10;&#10;  /**&#10;   * Bu node'u JSON olarak dışa aktarır.&#10;   */&#10;  exportJSON(): SerializedPageNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'page',&#10;      version: 1&#10;    };&#10;  }&#10;&#10;  /**&#10;   * Header, content ve footer node'larının varlığını ve sırasını garanti eder.&#10;   *&#10;   * Bu fonksiyon, bir sayfa node'unun çocukları arasında mutlaka bir header, bir content ve bir footer node'u olmasını sağlar.&#10;   * Eğer eksik varsa otomatik olarak ekler ve sıralamayı header -&gt; content -&gt; footer olarak düzeltir.&#10;   *&#10;   * Kullanım Senaryosu:&#10;   * - Sayfa ilk oluşturulurken veya çocuklar değiştiğinde, yapının bozulmaması için çağrılır.&#10;   *&#10;   * Not: Tüm mevcut çocuklar önce kaldırılır, sonra doğru sırayla tekrar eklenir.&#10;   */&#10;  ensureHeaderFooterContentChildren(): void {&#10;    // Sıralama: header -&gt; content -&gt; footer (section her zaman ortada)&#10;    let header = this.getChildren().find((child) =&gt; child.getType() === 'page-header');&#10;    let content = this.getChildren().find((child) =&gt; child.getType() === 'page-content');&#10;    let footer = this.getChildren().find((child) =&gt; child.getType() === 'page-footer');&#10;    if (header == null) header = new PageHeaderNode('', undefined, false);&#10;    if (content == null) content = new PageContentNode();&#10;    if (footer == null) footer = new PageFooterNode('', undefined, false);&#10;    // Tüm çocukları kaldır ve doğru sırayla ekle&#10;    this.getChildren().forEach((child) =&gt; {&#10;      // Her bir mevcut çocuğu kaldırıyoruz, böylece sıralama bozulmaz.&#10;      child.remove();&#10;    });&#10;    // Doğru sırayla header, content ve footer ekleniyor.&#10;    this.append(header);&#10;    this.append(content);&#10;    this.append(footer);&#10;  }&#10;&#10;  /**&#10;   * Başlangıçta header, content ve footer ekler.&#10;   */&#10;  appendInitialChildren(): void {&#10;    this.ensureHeaderFooterContentChildren();&#10;  }&#10;&#10;  /**&#10;   * Header node'unu döndürür.&#10;   */&#10;  getHeaderNode(): PageHeaderNode | undefined {&#10;    return this.getChildren().find((child) =&gt; child.getType() === 'page-header') as PageHeaderNode;&#10;  }&#10;&#10;  /**&#10;   * Footer node'unu döndürür.&#10;   */&#10;  getFooterNode(): PageFooterNode | undefined {&#10;    return this.getChildren().find((child) =&gt; child.getType() === 'page-footer') as PageFooterNode;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/SectionNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/SectionNode.tsx" />
              <option name="updatedContent" value="import { ElementNode, SerializedElementNode, EditorConfig, Spread } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedSectionNode = Spread&lt;&#10;  {&#10;    type: 'section';&#10;    version: 1;&#10;  },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;export class SectionNode extends ElementNode {&#10;  static getType(): string {&#10;    return 'section';&#10;  }&#10;&#10;  static clone(node: SectionNode): SectionNode {&#10;    return new SectionNode(node.__key);&#10;  }&#10;&#10;  createDOM(_config: EditorConfig): HTMLElement {&#10;    const dom = document.createElement('section');&#10;    dom.className = 'a4-section';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  static importJSON(_serializedNode: SerializedSectionNode): SectionNode {&#10;    return new SectionNode();&#10;  }&#10;&#10;  exportJSON(): SerializedSectionNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'section',&#10;      version: 1,&#10;    };&#10;  }&#10;&#10;  decorate(): JSX.Element | null {&#10;    return null;&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/sectionTypeGuards.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/sectionTypeGuards.ts" />
              <option name="originalContent" value="// sectionTypeGuards: Sayfa node'larının tipini kontrol etmek için yardımcı fonksiyonlar içerir.&#10;// isContentNode, isHeaderNode ve isFooterNode ile node'un tipini kolayca kontrol edebilirsiniz.&#10;&#10;import type { LexicalNode } from 'lexical';&#10;import { PageContentNode } from './PageContentNode';&#10;import { PageHeaderNode } from './PageHeaderNode';&#10;import { PageFooterNode } from './PageFooterNode';&#10;&#10;/**&#10; * Verilen node'un PageContentNode olup olmadığını kontrol eder.&#10; */&#10;export function isContentNode(node: LexicalNode | null | undefined): node is PageContentNode {&#10;  return node instanceof PageContentNode;&#10;}&#10;&#10;/**&#10; * Verilen node'un PageHeaderNode olup olmadığını kontrol eder.&#10; */&#10;export function isHeaderNode(node: LexicalNode | null | undefined): node is PageHeaderNode {&#10;  return node instanceof PageHeaderNode;&#10;}&#10;&#10;/**&#10; * Verilen node'un PageFooterNode olup olmadığını kontrol eder.&#10; */&#10;export function isFooterNode(node: LexicalNode | null | undefined): node is PageFooterNode {&#10;  return node instanceof PageFooterNode;&#10;}&#10;&#10;// PageContentNode, PageHeaderNode ve PageFooterNode tiplerini dışa aktarır.&#10;export type { PageContentNode, PageHeaderNode, PageFooterNode };&#10;" />
              <option name="updatedContent" value="// sectionTypeGuards: Sayfa node'larının tipini kontrol etmek için yardımcı fonksiyonlar içerir.&#10;// isContentNode, isHeaderNode ve isFooterNode ile node'un tipini kolayca kontrol edebilirsiniz.&#10;// Her fonksiyon, LexicalNode'un belirli bir node tipine ait olup olmadığını anlamak için instanceof kullanır.&#10;&#10;import type { LexicalNode } from 'lexical';&#10;import { PageContentNode } from './PageContentNode';&#10;import { PageHeaderNode } from './PageHeaderNode';&#10;import { PageFooterNode } from './PageFooterNode';&#10;&#10;/**&#10; * Verilen node'un PageContentNode olup olmadığını kontrol eder.&#10; *&#10; * @param node - Kontrol edilecek LexicalNode nesnesi (null veya undefined olabilir)&#10; * @returns Eğer node bir PageContentNode ise true, değilse false döner.&#10; *&#10; * Not: instanceof ile tip kontrolü yapılır. Bu sayede LexicalNode'un&#10; * gerçekten PageContentNode olup olmadığı güvenli şekilde anlaşılır.&#10; */&#10;export function isContentNode(node: LexicalNode | null | undefined): node is PageContentNode {&#10;  // node null veya undefined ise false döner, aksi halde instanceof ile kontrol edilir&#10;  return node instanceof PageContentNode;&#10;}&#10;&#10;/**&#10; * Verilen node'un PageHeaderNode olup olmadığını kontrol eder.&#10; *&#10; * @param node - Kontrol edilecek LexicalNode nesnesi (null veya undefined olabilir)&#10; * @returns Eğer node bir PageHeaderNode ise true, değilse false döner.&#10; *&#10; * Not: instanceof ile tip kontrolü yapılır. Bu sayede LexicalNode'un&#10; * gerçekten PageHeaderNode olup olmadığı güvenli şekilde anlaşılır.&#10; */&#10;export function isHeaderNode(node: LexicalNode | null | undefined): node is PageHeaderNode {&#10;  // node null veya undefined ise false döner, aksi halde instanceof ile kontrol edilir&#10;  return node instanceof PageHeaderNode;&#10;}&#10;&#10;/**&#10; * Verilen node'un PageFooterNode olup olmadığını kontrol eder.&#10; *&#10; * @param node - Kontrol edilecek LexicalNode nesnesi (null veya undefined olabilir)&#10; * @returns Eğer node bir PageFooterNode ise true, değilse false döner.&#10; *&#10; * Not: instanceof ile tip kontrolü yapılır. Bu sayede LexicalNode'un&#10; * gerçekten PageFooterNode olup olmadığı güvenli şekilde anlaşılır.&#10; */&#10;export function isFooterNode(node: LexicalNode | null | undefined): node is PageFooterNode {&#10;  // node null veya undefined ise false döner, aksi halde instanceof ile kontrol edilir&#10;  return node instanceof PageFooterNode;&#10;}&#10;&#10;// PageContentNode, PageHeaderNode ve PageFooterNode tiplerini dışa aktarır.&#10;export type { PageContentNode, PageHeaderNode, PageFooterNode };" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/ContentSelectAllPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/ContentSelectAllPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEffect } from 'react';&#10;import { KEY_MODIFIER_COMMAND, COMMAND_PRIORITY_CRITICAL } from 'lexical';&#10;&#10;export function ContentSelectAllPlugin(): JSX.Element | null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    const unregister = editor.registerCommand(&#10;      KEY_MODIFIER_COMMAND,&#10;      (event: KeyboardEvent) =&gt; {&#10;        if ((event.ctrlKey || event.metaKey) &amp;&amp; (event.key === 'a' || event.key === 'A')) {&#10;          const content = document.querySelector('.a4-content');&#10;          if (content === null) return false;&#10;          event.preventDefault();&#10;          const range = document.createRange();&#10;          range.selectNodeContents(content);&#10;          const sel = window.getSelection();&#10;          if (sel === null) return true;&#10;          sel.removeAllRanges();&#10;          sel.addRange(range);&#10;          return true; // handled&#10;        }&#10;        return false;&#10;      },&#10;      COMMAND_PRIORITY_CRITICAL&#10;    );&#10;    return unregister;&#10;  }, [editor]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * ContentSelectAllPlugin&#10; *&#10; * Bu plugin, Ctrl+A (veya Mac'te Cmd+A) kısayoluna basıldığında sadece .a4-content alanındaki tüm içeriği seçer.&#10; * Böylece kullanıcı, sayfa içeriğini kolayca topluca seçebilir.&#10; *&#10; * Kullanım Senaryosu:&#10; * - Standart Ctrl+A davranışını override ederek, sadece içerik alanını seçmek için kullanılır.&#10; *&#10; * Notlar:&#10; * - Lexical editörün registerCommand API'si ile global kısayol dinlenir.&#10; * - DOM'da .a4-content class'ı ile işaretli alan hedeflenir.&#10; */&#10;&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEffect } from 'react';&#10;import { KEY_MODIFIER_COMMAND, COMMAND_PRIORITY_CRITICAL } from 'lexical';&#10;&#10;export function ContentSelectAllPlugin(): JSX.Element | null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    // Ctrl+A veya Cmd+A tuş kombinasyonunu dinle.&#10;    // Eğer .a4-content alanı varsa, tüm içeriği seç.&#10;    const unregister = editor.registerCommand(&#10;      KEY_MODIFIER_COMMAND,&#10;      (event: KeyboardEvent) =&gt; {&#10;        if ((event.ctrlKey || event.metaKey) &amp;&amp; (event.key === 'a' || event.key === 'A')) {&#10;          // .a4-content alanını bul&#10;          const content = document.querySelector('.a4-content');&#10;          if (content === null) return false;&#10;          event.preventDefault();&#10;          // Range ile tüm içeriği seç&#10;          const range = document.createRange();&#10;          range.selectNodeContents(content);&#10;          const sel = window.getSelection();&#10;          if (sel === null) return true;&#10;          sel.removeAllRanges();&#10;          sel.addRange(range);&#10;          return true; // handled&#10;        }&#10;        return false;&#10;      },&#10;      COMMAND_PRIORITY_CRITICAL&#10;    );&#10;    return unregister;&#10;  }, [editor]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/HeaderFooterSyncPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/HeaderFooterSyncPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEffect, useRef } from 'react';&#10;import { $getRoot } from 'lexical';&#10;import { updateAllHeaders, updateAllFooters } from '../utils/HeaderFooterSyncUtils';&#10;import { $isPageNode } from '../nodes/PageNode';&#10;&#10;/**&#10; * HeaderFooterSyncPlugin&#10; *&#10; * Bu plugin, header/footer edit modundayken bir header/footer değişikliği olduğunda&#10; * tüm sayfalardaki header/footer'ı otomatik olarak günceller.&#10; *&#10; * Kullanım Senaryosu:&#10; * - Kullanıcı bir sayfanın header veya footer'ını değiştirdiğinde, tüm sayfalarda aynı değişikliğin yansımasını sağlar.&#10; *&#10; * Notlar:&#10; * - updateAllHeaders ve updateAllFooters yardımcı fonksiyonlarını kullanır.&#10; * - Her güncellemede PageNode'larda header/footer'ın varlığını da garanti eder.&#10; */&#10;export function HeaderFooterSyncPlugin(): JSX.Element | null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const lastHeader = useRef&lt;{ text: string; visible: boolean } | null&gt;(null);&#10;  const lastFooter = useRef&lt;{ text: string; visible: boolean } | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    // Lexical editörün state'i güncellendiğinde çalışır.&#10;    // Header veya footer'da değişiklik olup olmadığını tespit eder.&#10;    return editor.registerUpdateListener(({ editorState }) =&gt; {&#10;      editorState.read(() =&gt; {&#10;        const root = $getRoot();&#10;        // Tüm sayfalardaki header/footer'ları topla&#10;        const pageNodes = root.getChildren().filter($isPageNode);&#10;        let changedHeader: { text: string; visible: boolean } | null = null;&#10;        let changedFooter: { text: string; visible: boolean } | null = null;&#10;        // Header değişikliği tespiti&#10;        for (const page of pageNodes) {&#10;          const header = page.getHeaderNode();&#10;          if (header != null) {&#10;            // Son header ile mevcut header karşılaştırılır&#10;            if (&#10;              lastHeader.current == null ||&#10;              lastHeader.current.text !== header.__text ||&#10;              lastHeader.current.visible !== header.__visible&#10;            ) {&#10;              changedHeader = { text: header.__text, visible: header.__visible };&#10;              break;&#10;            }&#10;          }&#10;        }&#10;        // Footer değişikliği tespiti&#10;        for (const page of pageNodes) {&#10;          const footer = page.getFooterNode();&#10;          if (footer != null) {&#10;            // Son footer ile mevcut footer karşılaştırılır&#10;            if (&#10;              lastFooter.current == null ||&#10;              lastFooter.current.text !== footer.__text ||&#10;              lastFooter.current.visible !== footer.__visible&#10;            ) {&#10;              changedFooter = { text: footer.__text, visible: footer.__visible };&#10;              break;&#10;            }&#10;          }&#10;        }&#10;        // Değişiklik yapılan header'ı tüm sayfalara uygula&#10;        if (changedHeader != null) {&#10;          const header = changedHeader; // TS için non-null&#10;          editor.update(() =&gt; {&#10;            updateAllHeaders(header.text, header.visible);&#10;          });&#10;          lastHeader.current = header;&#10;        }&#10;        // Değişiklik yapılan footer'ı tüm sayfalara uygula&#10;        if (changedFooter != null) {&#10;          const footer = changedFooter; // TS için non-null&#10;          editor.update(() =&gt; {&#10;            updateAllFooters(footer.text, footer.visible);&#10;          });&#10;          lastFooter.current = footer;&#10;        }&#10;        // Her güncellemede tüm PageNode'larda header/footer'ın varlığını garanti et&#10;        editor.update(() =&gt; {&#10;          pageNodes.forEach((page) =&gt; {&#10;            if (typeof page.ensureHeaderFooterContentChildren === 'function') {&#10;              page.ensureHeaderFooterContentChildren();&#10;            }&#10;          });&#10;        });&#10;      });&#10;    });&#10;  }, [editor]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEffect, useRef } from 'react';&#10;import { $getRoot } from 'lexical';&#10;import { updateAllHeaders, updateAllFooters } from '../utils/HeaderFooterSyncUtils';&#10;import { $isPageNode } from '../nodes/PageNode';&#10;&#10;/**&#10; * HeaderFooterSyncPlugin&#10; *&#10; * Bu plugin, header/footer edit modundayken bir header/footer değişikliği olduğunda&#10; * tüm sayfalardaki header/footer'ı otomatik olarak günceller.&#10; *&#10; * Kullanım Senaryosu:&#10; * - Kullanıcı bir sayfanın header veya footer'ını değiştirdiğinde, tüm sayfalarda aynı değişikliğin yansımasını sağlar.&#10; *&#10; * Notlar:&#10; * - updateAllHeaders ve updateAllFooters yardımcı fonksiyonlarını kullanır.&#10; * - Her güncellemede PageNode'larda header/footer'ın varlığını da garanti eder.&#10; */&#10;export function HeaderFooterSyncPlugin(): JSX.Element | null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const lastHeader = useRef&lt;{ text: string; visible: boolean } | null&gt;(null);&#10;  const lastFooter = useRef&lt;{ text: string; visible: boolean } | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    // Lexical editörün state'i güncellendiğinde çalışır.&#10;    // Header veya footer'da değişiklik olup olmadığını tespit eder.&#10;    return editor.registerUpdateListener(({ editorState }) =&gt; {&#10;      editorState.read(() =&gt; {&#10;        const root = $getRoot();&#10;        // Tüm sayfalardaki header/footer'ları topla&#10;        const pageNodes = root.getChildren().filter($isPageNode);&#10;        let changedHeader: { text: string; visible: boolean } | null = null;&#10;        let changedFooter: { text: string; visible: boolean } | null = null;&#10;        // Header değişikliği tespiti&#10;        for (const page of pageNodes) {&#10;          const header = page.getHeaderNode();&#10;          if (header != null) {&#10;            // Son header ile mevcut header karşılaştırılır&#10;            if (&#10;              lastHeader.current == null ||&#10;              lastHeader.current.text !== header.__text ||&#10;              lastHeader.current.visible !== header.__visible&#10;            ) {&#10;              changedHeader = { text: header.__text, visible: header.__visible };&#10;              break;&#10;            }&#10;          }&#10;        }&#10;        // Footer değişikliği tespiti&#10;        for (const page of pageNodes) {&#10;          const footer = page.getFooterNode();&#10;          if (footer != null) {&#10;            // Son footer ile mevcut footer karşılaştırılır&#10;            if (&#10;              lastFooter.current == null ||&#10;              lastFooter.current.text !== footer.__text ||&#10;              lastFooter.current.visible !== footer.__visible&#10;            ) {&#10;              changedFooter = { text: footer.__text, visible: footer.__visible };&#10;              break;&#10;            }&#10;          }&#10;        }&#10;        // Değişiklik yapılan header'ı tüm sayfalara uygula&#10;        if (changedHeader != null) {&#10;          const header = changedHeader; // TS için non-null&#10;          editor.update(() =&gt; {&#10;            updateAllHeaders(header.text, header.visible);&#10;            // Header değişikliği olduğunda header/footer varlığını garanti et&#10;            pageNodes.forEach((page) =&gt; {&#10;              if (typeof page.ensureHeaderFooterContentChildren === 'function') {&#10;                page.ensureHeaderFooterContentChildren();&#10;              }&#10;            });&#10;          });&#10;          lastHeader.current = header;&#10;        }&#10;        // Değişiklik yapılan footer'ı tüm sayfalara uygula&#10;        if (changedFooter != null) {&#10;          const footer = changedFooter; // TS için non-null&#10;          editor.update(() =&gt; {&#10;            updateAllFooters(footer.text, footer.visible);&#10;            // Footer değişikliği olduğunda header/footer varlığını garanti et&#10;            pageNodes.forEach((page) =&gt; {&#10;              if (typeof page.ensureHeaderFooterContentChildren === 'function') {&#10;                page.ensureHeaderFooterContentChildren();&#10;              }&#10;            });&#10;          });&#10;          lastFooter.current = footer;&#10;        }&#10;      });&#10;    });&#10;  }, [editor]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/HeaderFooterSyncUtils.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/HeaderFooterSyncUtils.ts" />
              <option name="originalContent" value="import { $getRoot } from 'lexical';&#10;import { $isPageNode } from '../nodes/PageNode';&#10;&#10;/**&#10; * Tüm PageNode'ların header'ını verilen text ve visible ile günceller&#10; */&#10;export function updateAllHeaders(text: string, visible: boolean): void {&#10;  const root = $getRoot();&#10;  root.getChildren().forEach((pageNode) =&gt; {&#10;    if ($isPageNode(pageNode)) {&#10;      const header = pageNode.getHeaderNode();&#10;      if (header != null) {&#10;        header.setText(text);&#10;        header.setVisible(visible);&#10;      }&#10;    }&#10;  });&#10;}&#10;&#10;/**&#10; * Tüm PageNode'ların footer'ını verilen text ve visible ile günceller&#10; */&#10;export function updateAllFooters(text: string, visible: boolean): void {&#10;  const root = $getRoot();&#10;  root.getChildren().forEach((pageNode) =&gt; {&#10;    if ($isPageNode(pageNode)) {&#10;      const footer = pageNode.getFooterNode();&#10;      if (footer != null) {&#10;        footer.setText(text);&#10;        footer.setVisible(visible);&#10;      }&#10;    }&#10;  });&#10;}&#10;" />
              <option name="updatedContent" value="import { $getRoot } from 'lexical';&#10;import { $isPageNode } from '../nodes/PageNode';&#10;&#10;/**&#10; * HeaderFooterSyncUtils&#10; *&#10; * Bu dosya, tüm sayfalardaki header ve footer alanlarını topluca güncellemek için yardımcı fonksiyonlar içerir.&#10; *&#10; * updateAllHeaders: Tüm PageNode'ların header'ını verilen text ve visible ile günceller.&#10; * updateAllFooters: Tüm PageNode'ların footer'ını verilen text ve visible ile günceller.&#10; *&#10; * Kullanım Senaryosu:&#10; * - Bir header/footer değişikliği olduğunda, tüm sayfalarda aynı değerin yansımasını sağlamak için kullanılır.&#10; */&#10;&#10;/**&#10; * Tüm PageNode'ların header'ını verilen text ve visible ile günceller&#10; */&#10;export function updateAllHeaders(text: string, visible: boolean): void {&#10;  // Root node'dan tüm PageNode'ları bulup, her birinin header'ını günceller.&#10;  const root = $getRoot();&#10;  root.getChildren().forEach((pageNode) =&gt; {&#10;    if ($isPageNode(pageNode)) {&#10;      const header = pageNode.getHeaderNode();&#10;      if (header != null) {&#10;        // Header'ın metni ve görünürlüğü güncellenir.&#10;        header.setText(text);&#10;        header.setVisible(visible);&#10;      }&#10;    }&#10;  });&#10;}&#10;&#10;/**&#10; * Tüm PageNode'ların footer'ını verilen text ve visible ile günceller&#10; */&#10;export function updateAllFooters(text: string, visible: boolean): void {&#10;  // Root node'dan tüm PageNode'ları bulup, her birinin footer'ını günceller.&#10;  const root = $getRoot();&#10;  root.getChildren().forEach((pageNode) =&gt; {&#10;    if ($isPageNode(pageNode)) {&#10;      const footer = pageNode.getFooterNode();&#10;      if (footer != null) {&#10;        // Footer'ın metni ve görünürlüğü güncellenir.&#10;        footer.setText(text);&#10;        footer.setVisible(visible);&#10;      }&#10;    }&#10;  });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/PageAutoSplitPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/PageAutoSplitPlugin.tsx" />
              <option name="originalContent" value="import { useEffect, useRef } from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { $createPageNode, $isPageNode, type PageNode } from '../nodes/PageNode';&#10;import { isContentNode, isHeaderNode, isFooterNode } from '../nodes/sectionTypeGuards';&#10;import { PageHeaderNode } from '../nodes/PageHeaderNode';&#10;import { PageFooterNode } from '../nodes/PageFooterNode';&#10;import { PageContentNode } from '../nodes/PageContentNode';&#10;&#10;export interface PageFlowSettings {&#10;  pageHeightMm: number;&#10;  marginTopMm: number;&#10;  marginBottomMm: number;&#10;}&#10;&#10;export function PageAutoSplitPlugin({&#10;  pageHeightMm,&#10;  marginTopMm,&#10;  marginBottomMm&#10;}: PageFlowSettings): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const rafRef = useRef&lt;number | null&gt;(null);&#10;  const isReflowingRef = useRef(false);&#10;&#10;  useEffect(() =&gt; {&#10;    function getPageEl(page: PageNode): HTMLElement | null {&#10;      return editor.getElementByKey(page.getKey());&#10;    }&#10;&#10;    function getContentMetrics(pageEl: HTMLElement): {&#10;      el: HTMLElement | null;&#10;      top: number;&#10;      bottom: number;&#10;      height: number;&#10;      paddingTop: number;&#10;      paddingBottom: number;&#10;    } {&#10;      const el = pageEl.querySelector('[data-lexical-page-section=&quot;content&quot;]');&#10;      const contentEl = el instanceof HTMLElement ? el : null;&#10;      const target = contentEl ?? pageEl;&#10;      const rect = target.getBoundingClientRect();&#10;      const styles = window.getComputedStyle(target);&#10;      let paddingTop = parseFloat(styles.paddingTop);&#10;      let paddingBottom = parseFloat(styles.paddingBottom);&#10;      if (Number.isNaN(paddingTop)) paddingTop = 0;&#10;      if (Number.isNaN(paddingBottom)) paddingBottom = 0;&#10;      const top = rect.top + paddingTop;&#10;      const bottom = rect.bottom - paddingBottom;&#10;      return { el: contentEl, top, bottom, height: bottom - top, paddingTop, paddingBottom };&#10;    }&#10;&#10;    function getContentScrollHeight(&#10;      targetEl: HTMLElement,&#10;      paddingTop: number,&#10;      paddingBottom: number&#10;    ): number {&#10;      return targetEl.scrollHeight - paddingTop - paddingBottom;&#10;    }&#10;&#10;    function moveOverflowBlocksToNextPage(pageNode: PageNode, capacity: number): void {&#10;      const contentSection = pageNode&#10;        .getChildren()&#10;        .find((c: unknown): c is PageContentNode =&gt; isContentNode(c));&#10;      if (contentSection == null) return;&#10;      const blocks = contentSection.getChildren();&#10;      if (blocks.length === 0) return;&#10;      const el = editor.getElementByKey(contentSection.getKey());&#10;      if (el == null) return;&#10;      // Footer yüksekliğini ve en az bir satır boşluğu hesaba kat&#10;      const pageFooter = pageNode.getChildren().find((n) =&gt; isFooterNode(n));&#10;      let footerHeight = 0;&#10;      if (pageFooter != null) {&#10;        const footerEl = editor.getElementByKey(pageFooter.getKey());&#10;        if (footerEl != null) {&#10;          footerHeight = footerEl.offsetHeight;&#10;        }&#10;      }&#10;      // En az bir satır boşluk (ör: 24px) bırakmak için&#10;      const minLineGap = 24;&#10;      const adjustedCapacity = capacity - footerHeight - minLineGap;&#10;      if (!(el.scrollHeight &gt; adjustedCapacity + 2)) return;&#10;      // Fazla bloğu bul ve taşı&#10;      let nextPage = pageNode.getNextSibling();&#10;      if (!$isPageNode(nextPage)) {&#10;        nextPage = $createPageNode();&#10;        // Header/footer kopyala&#10;        const prevHeader = pageNode.getChildren().find((n) =&gt; isHeaderNode(n));&#10;        const prevFooter = pageNode.getChildren().find((n) =&gt; isFooterNode(n));&#10;        if (prevHeader != null &amp;&amp; prevHeader.__visible !== false) {&#10;          nextPage.append(&#10;            new PageHeaderNode(prevHeader.__text ?? '', undefined, prevHeader.__visible ?? false)&#10;          );&#10;        }&#10;        nextPage.append(new PageContentNode());&#10;        if (prevFooter != null &amp;&amp; prevFooter.__visible !== false) {&#10;          nextPage.append(&#10;            new PageFooterNode(prevFooter.__text ?? '', undefined, prevFooter.__visible ?? false)&#10;          );&#10;        }&#10;        pageNode.insertAfter(nextPage);&#10;      }&#10;      const nextContent = nextPage&#10;        .getChildren()&#10;        .find((c: unknown): c is PageContentNode =&gt; isContentNode(c));&#10;      if (nextContent == null) return;&#10;      // Son bloğu taşı&#10;      const lastBlock = blocks[blocks.length - 1];&#10;      // Sadece null kontrolü ve getKey fonksiyonu kontrolü yeterli&#10;      if (lastBlock != null &amp;&amp; typeof (lastBlock as { getKey?: unknown }).getKey === 'function') {&#10;        nextContent.append(lastBlock as any); // LexicalNode olarak cast&#10;      }&#10;    }&#10;&#10;    function reflowPass(): boolean {&#10;      let didMoveAny = false;&#10;      editor.update(() =&gt; {&#10;        const root = $getRoot();&#10;        if (root.getChildrenSize() === 0) {&#10;          root.append($createPageNode());&#10;          return;&#10;        }&#10;        const children = root.getChildren();&#10;        const hasNonPage = children.some((n) =&gt; !$isPageNode(n));&#10;        if (hasNonPage) {&#10;          const page = $createPageNode();&#10;          children.forEach((n) =&gt; {&#10;            // Sadece LexicalNode tipindekileri ekle&#10;            if (!$isPageNode(n) &amp;&amp; typeof n === 'object' &amp;&amp; n !== null &amp;&amp; 'getKey' in n) {&#10;              const contentSection = page&#10;                .getChildren()&#10;                .find((c: unknown): c is PageContentNode =&gt; isContentNode(c));&#10;              if (contentSection != null) contentSection.append(n as any); // LexicalNode olarak cast&#10;            }&#10;          });&#10;          root.append(page);&#10;        }&#10;        // Tüm sayfalar için flow kontrolü&#10;        let page = root.getFirstChild();&#10;        while ($isPageNode(page)) {&#10;          const pageNode = page;&#10;          const pageEl = getPageEl(pageNode);&#10;          if (pageEl === null) {&#10;            page = pageNode.getNextSibling();&#10;            continue;&#10;          }&#10;          const {&#10;            el: contentDomEl,&#10;            height: capacity,&#10;            paddingTop,&#10;            paddingBottom&#10;          } = getContentMetrics(pageEl);&#10;          const targetForScroll = contentDomEl !== null ? contentDomEl : pageEl;&#10;          const usedScroll = getContentScrollHeight(targetForScroll, paddingTop, paddingBottom);&#10;          if (usedScroll &gt; capacity + 2) {&#10;            moveOverflowBlocksToNextPage(pageNode, capacity);&#10;            didMoveAny = true;&#10;          }&#10;          page = pageNode.getNextSibling();&#10;        }&#10;      });&#10;      return didMoveAny;&#10;    }&#10;&#10;    const schedule = (): void =&gt; {&#10;      if (isReflowingRef.current) return;&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      rafRef.current = requestAnimationFrame(() =&gt; {&#10;        isReflowingRef.current = true;&#10;        let passes = 0;&#10;        const maxPasses = 30;&#10;        const run = (): void =&gt; {&#10;          const moved = reflowPass();&#10;          passes++;&#10;          if (moved &amp;&amp; passes &lt; maxPasses) {&#10;            setTimeout(run, 0);&#10;          } else {&#10;            isReflowingRef.current = false;&#10;          }&#10;        };&#10;        setTimeout(run, 0);&#10;      });&#10;    };&#10;&#10;    schedule();&#10;&#10;    const unregister = editor.registerUpdateListener((): void =&gt; {&#10;      schedule();&#10;    });&#10;&#10;    return (): void =&gt; {&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      unregister();&#10;      isReflowingRef.current = false;&#10;    };&#10;  }, [editor, pageHeightMm, marginTopMm, marginBottomMm]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * PageAutoSplitPlugin&#10; *&#10; * Bu plugin, sayfa içeriği taşma (overflow) yaptığında fazla blokları otomatik olarak yeni bir sayfaya taşır.&#10; * Sayfa yüksekliği, üst ve alt marjlar gibi parametrelerle çalışır ve overflow durumunda yeni sayfa ekler.&#10; *&#10; * Kullanım Senaryosu:&#10; * - Kullanıcı içerik ekledikçe, sayfa dolduğunda fazla bloklar otomatik olarak yeni bir sayfaya aktarılır.&#10; * - Header/footer kopyalanır, içerik bölünür ve sayfa yapısı bozulmaz.&#10; *&#10; * Notlar:&#10; * - moveOverflowBlocksToNextPage fonksiyonu, taşan blokları bir sonraki sayfaya taşır.&#10; * - reflowPass fonksiyonu, tüm sayfaları kontrol eder ve overflow varsa taşımayı tetikler.&#10; * - schedule fonksiyonu, animasyon frame ve setTimeout ile reflow işlemini optimize eder.&#10; */&#10;&#10;import { useEffect, useRef } from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { $createPageNode, $isPageNode, type PageNode } from '../nodes/PageNode';&#10;import { isContentNode, isHeaderNode, isFooterNode } from '../nodes/sectionTypeGuards';&#10;import { PageHeaderNode } from '../nodes/PageHeaderNode';&#10;import { PageFooterNode } from '../nodes/PageFooterNode';&#10;import { PageContentNode } from '../nodes/PageContentNode';&#10;&#10;export interface PageFlowSettings {&#10;  pageHeightMm: number;&#10;  marginTopMm: number;&#10;  marginBottomMm: number;&#10;}&#10;&#10;export function PageAutoSplitPlugin({&#10;  pageHeightMm,&#10;  marginTopMm,&#10;  marginBottomMm&#10;}: PageFlowSettings): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const rafRef = useRef&lt;number | null&gt;(null);&#10;  const isReflowingRef = useRef(false);&#10;&#10;  useEffect(() =&gt; {&#10;    function getPageEl(page: PageNode): HTMLElement | null {&#10;      return editor.getElementByKey(page.getKey());&#10;    }&#10;&#10;    function getContentMetrics(pageEl: HTMLElement): {&#10;      el: HTMLElement | null;&#10;      top: number;&#10;      bottom: number;&#10;      height: number;&#10;      paddingTop: number;&#10;      paddingBottom: number;&#10;    } {&#10;      const el = pageEl.querySelector('[data-lexical-page-section=&quot;content&quot;]');&#10;      const contentEl = el instanceof HTMLElement ? el : null;&#10;      const target = contentEl ?? pageEl;&#10;      const rect = target.getBoundingClientRect();&#10;      const styles = window.getComputedStyle(target);&#10;      let paddingTop = parseFloat(styles.paddingTop);&#10;      let paddingBottom = parseFloat(styles.paddingBottom);&#10;      if (Number.isNaN(paddingTop)) paddingTop = 0;&#10;      if (Number.isNaN(paddingBottom)) paddingBottom = 0;&#10;      const top = rect.top + paddingTop;&#10;      const bottom = rect.bottom - paddingBottom;&#10;      return { el: contentEl, top, bottom, height: bottom - top, paddingTop, paddingBottom };&#10;    }&#10;&#10;    function getContentScrollHeight(&#10;      targetEl: HTMLElement,&#10;      paddingTop: number,&#10;      paddingBottom: number&#10;    ): number {&#10;      return targetEl.scrollHeight - paddingTop - paddingBottom;&#10;    }&#10;&#10;    /**&#10;     * moveOverflowBlocksToNextPage&#10;     *&#10;     * Bu fonksiyon, taşan içerik bloklarını bir sonraki sayfaya taşır.&#10;     * Sayfa altındaki footer yüksekliği ve minimum boşluk göz önünde bulundurularak&#10;     * taşınacak içerik miktarı ayarlanır.&#10;     *&#10;     * @param pageNode - Taşınacak blokların bulunduğu sayfa düğümü&#10;     * @param capacity - Sayfanın içeriği barındırma kapasitesi&#10;     */&#10;    function moveOverflowBlocksToNextPage(pageNode: PageNode, capacity: number): void {&#10;      // İçerik bölümünü bul&#10;      const contentSection = pageNode&#10;        .getChildren()&#10;        .find((c: unknown): c is PageContentNode =&gt; isContentNode(c));&#10;      if (contentSection == null) return;&#10;      const blocks = contentSection.getChildren();&#10;      if (blocks.length === 0) return;&#10;      const el = editor.getElementByKey(contentSection.getKey());&#10;      if (el == null) return;&#10;      // Footer yüksekliğini ve en az bir satır boşluğu hesaba kat&#10;      const pageFooter = pageNode.getChildren().find((n) =&gt; isFooterNode(n));&#10;      let footerHeight = 0;&#10;      if (pageFooter != null) {&#10;        const footerEl = editor.getElementByKey(pageFooter.getKey());&#10;        if (footerEl != null) {&#10;          footerHeight = footerEl.offsetHeight;&#10;        }&#10;      }&#10;      // En az bir satır boşluk (ör: 24px) bırakmak için&#10;      const minLineGap = 24;&#10;      const adjustedCapacity = capacity - footerHeight - minLineGap;&#10;      if (!(el.scrollHeight &gt; adjustedCapacity + 2)) return;&#10;      // Fazla bloğu bul ve taşı&#10;      let nextPage = pageNode.getNextSibling();&#10;      if (!$isPageNode(nextPage)) {&#10;        nextPage = $createPageNode();&#10;        // Header/footer kopyala&#10;        const prevHeader = pageNode.getChildren().find((n) =&gt; isHeaderNode(n));&#10;        const prevFooter = pageNode.getChildren().find((n) =&gt; isFooterNode(n));&#10;        if (prevHeader != null &amp;&amp; prevHeader.__visible !== false) {&#10;          nextPage.append(&#10;            new PageHeaderNode(prevHeader.__text ?? '', undefined, prevHeader.__visible ?? false)&#10;          );&#10;        }&#10;        nextPage.append(new PageContentNode());&#10;        if (prevFooter != null &amp;&amp; prevFooter.__visible !== false) {&#10;          nextPage.append(&#10;            new PageFooterNode(prevFooter.__text ?? '', undefined, prevFooter.__visible ?? false)&#10;          );&#10;        }&#10;        pageNode.insertAfter(nextPage);&#10;      }&#10;      const nextContent = nextPage&#10;        .getChildren()&#10;        .find((c: unknown): c is PageContentNode =&gt; isContentNode(c));&#10;      if (nextContent == null) return;&#10;      // Son bloğu taşı&#10;      const lastBlock = blocks[blocks.length - 1];&#10;      // Sadece null kontrolü ve getKey fonksiyonu kontrolü yeterli&#10;      if (lastBlock != null &amp;&amp; typeof (lastBlock as { getKey?: unknown }).getKey === 'function') {&#10;        // Fazla bloğu bir sonraki sayfanın content'ine ekle&#10;        nextContent.append(lastBlock as any); // LexicalNode olarak cast&#10;      }&#10;    }&#10;&#10;    /**&#10;     * reflowPass&#10;     *&#10;     * Bu fonksiyon, sayfa taşma kontrolü yapar ve gerekirse taşma olan sayfalardaki&#10;     * fazla blokları bir sonraki sayfaya taşır.&#10;     *&#10;     * @returns boolean - Herhangi bir bloğun taşınıp taşınmadığını belirtir&#10;     */&#10;    function reflowPass(): boolean {&#10;      let didMoveAny = false;&#10;      editor.update(() =&gt; {&#10;        // Root node'u al&#10;        const root = $getRoot();&#10;        if (root.getChildrenSize() === 0) {&#10;          root.append($createPageNode());&#10;          return;&#10;        }&#10;        const children = root.getChildren();&#10;        // Eğer root altında PageNode olmayan bir node varsa, onu yeni bir sayfaya taşı&#10;        const hasNonPage = children.some((n) =&gt; !$isPageNode(n));&#10;        if (hasNonPage) {&#10;          const page = $createPageNode();&#10;          children.forEach((n) =&gt; {&#10;            // Sadece LexicalNode tipindekileri ekle&#10;            if (!$isPageNode(n) &amp;&amp; typeof n === 'object' &amp;&amp; n !== null &amp;&amp; 'getKey' in n) {&#10;              const contentSection = page&#10;                .getChildren()&#10;                .find((c: unknown): c is PageContentNode =&gt; isContentNode(c));&#10;              if (contentSection != null) contentSection.append(n as any); // LexicalNode olarak cast&#10;            }&#10;          });&#10;          root.append(page);&#10;        }&#10;        // Tüm sayfalar için flow kontrolü&#10;        let page = root.getFirstChild();&#10;        while ($isPageNode(page)) {&#10;          const pageNode = page;&#10;          const pageEl = getPageEl(pageNode);&#10;          if (pageEl === null) {&#10;            page = pageNode.getNextSibling();&#10;            continue;&#10;          }&#10;          // Sayfa içeriğinin kapasitesini ve kullanılan alanı hesapla&#10;          const {&#10;            el: contentDomEl,&#10;            height: capacity,&#10;            paddingTop,&#10;            paddingBottom&#10;          } = getContentMetrics(pageEl);&#10;          const targetForScroll = contentDomEl !== null ? contentDomEl : pageEl;&#10;          const usedScroll = getContentScrollHeight(targetForScroll, paddingTop, paddingBottom);&#10;          if (usedScroll &gt; capacity + 2) {&#10;            // Taşma varsa, fazla bloğu bir sonraki sayfaya taşı&#10;            moveOverflowBlocksToNextPage(pageNode, capacity);&#10;            didMoveAny = true;&#10;          }&#10;          page = pageNode.getNextSibling();&#10;        }&#10;      });&#10;      return didMoveAny;&#10;    }&#10;&#10;    const schedule = (): void =&gt; {&#10;      if (isReflowingRef.current) return;&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      rafRef.current = requestAnimationFrame(() =&gt; {&#10;        isReflowingRef.current = true;&#10;        let passes = 0;&#10;        const maxPasses = 30;&#10;        const run = (): void =&gt; {&#10;          const moved = reflowPass();&#10;          passes++;&#10;          if (moved &amp;&amp; passes &lt; maxPasses) {&#10;            setTimeout(run, 0);&#10;          } else {&#10;            isReflowingRef.current = false;&#10;          }&#10;        };&#10;        setTimeout(run, 0);&#10;      });&#10;    };&#10;&#10;    schedule();&#10;&#10;    const unregister = editor.registerUpdateListener((): void =&gt; {&#10;      schedule();&#10;    });&#10;&#10;    return (): void =&gt; {&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      unregister();&#10;      isReflowingRef.current = false;&#10;    };&#10;  }, [editor, pageHeightMm, marginTopMm, marginBottomMm]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/PageInitializerPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/PageInitializerPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect } from 'react';&#10;import { PageNode } from '../nodes/PageNode';&#10;&#10;export function PageInitializerPlugin(): JSX.Element | null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      if (root.getChildrenSize() === 0) {&#10;        const page = new PageNode({});&#10;        page.appendInitialChildren(); // Always add header/footer/content (header/footer hidden by default)&#10;        root.append(page);&#10;      }&#10;    });&#10;  }, [editor]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect } from 'react';&#10;import { PageNode } from '../nodes/PageNode';&#10;&#10;/**&#10; * PageInitializerPlugin&#10; *&#10; * Editör ilk açıldığında veya root node boşsa, otomatik olarak bir PageNode ekler.&#10; * Bu PageNode'un içine header, content ve footer bölümleri de eklenir (header/footer varsayılan olarak gizli).&#10; *&#10; * Kullanım Senaryosu:&#10; * - Editör ilk açıldığında, kullanıcıya boş bir sayfa sunmak için kullanılır.&#10; *&#10; * Notlar:&#10; * - page.appendInitialChildren fonksiyonu ile header/footer/content otomatik eklenir.&#10; */&#10;export function PageInitializerPlugin(): JSX.Element | null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    // Editör açıldığında veya root boşsa, bir PageNode ekle&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      if (root.getChildrenSize() === 0) {&#10;        const page = new PageNode({});&#10;        page.appendInitialChildren(); // Always add header/footer/content (header/footer hidden by default)&#10;        root.append(page);&#10;      }&#10;    });&#10;  }, [editor]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/SectionToolbarPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/SectionToolbarPlugin.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { PageNode } from '../nodes/PageNode';&#10;&#10;interface Props {&#10;  editMode: boolean;&#10;  setEditMode: (v: boolean) =&gt; void;&#10;  showHeader: boolean;&#10;  setShowHeader: (v: boolean) =&gt; void;&#10;  showFooter: boolean;&#10;  setShowFooter: (v: boolean) =&gt; void;&#10;}&#10;&#10;export function SectionToolbarPlugin({&#10;  editMode,&#10;  setEditMode,&#10;  showHeader,&#10;  setShowHeader,&#10;  showFooter,&#10;  setShowFooter,&#10;}: Props) {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  const handleAddSection = () =&gt; {&#10;    PageNode.createSection(editor);&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setEditMode(!editMode)}&#10;        className={editMode ? 'active' : ''}&#10;        style={{ marginLeft: 16 }}&#10;        title={editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;      &gt;&#10;        {editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;      &lt;/button&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setShowHeader(!showHeader)}&#10;        className={showHeader ? 'active' : ''}&#10;        style={{ marginLeft: 8 }}&#10;        title={showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;      &gt;&#10;        {showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;      &lt;/button&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setShowFooter(!showFooter)}&#10;        className={showFooter ? 'active' : ''}&#10;        style={{ marginLeft: 8 }}&#10;        title={showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;      &gt;&#10;        {showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;      &lt;/button&gt;&#10;      &lt;button&#10;        onClick={handleAddSection}&#10;        style={{ marginLeft: 8 }}&#10;        title=&quot;Section Ekle&quot;&#10;      &gt;&#10;        Section Ekle&#10;      &lt;/button&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { PageNode } from '../nodes/PageNode';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;&#10;interface Props {&#10;  editMode: boolean;&#10;  setEditMode: (v: boolean) =&gt; void;&#10;  showHeader: boolean;&#10;  setShowHeader: (v: boolean) =&gt; void;&#10;  showFooter: boolean;&#10;  setShowFooter: (v: boolean) =&gt; void;&#10;}&#10;&#10;export function SectionToolbarPlugin({&#10;  editMode,&#10;  setEditMode,&#10;  showHeader,&#10;  setShowHeader,&#10;  showFooter,&#10;  setShowFooter,&#10;}: Props) {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  const handleAddSection = () =&gt; {&#10;    PageNode.createSection(editor);&#10;  };&#10;&#10;  return (&#10;    &lt;Toolbar.Root className=&quot;toolbarRoot&quot;&gt;&#10;      &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={() =&gt; setEditMode(!editMode)}&#10;          className={`toolbarButton${editMode ? ' active' : ''}`}&#10;          title={editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;        &gt;&#10;          {editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;        &lt;/Toolbar.Button&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={() =&gt; setShowHeader(!showHeader)}&#10;          className={`toolbarButton${showHeader ? ' active' : ''}`}&#10;          title={showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;        &gt;&#10;          {showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;        &lt;/Toolbar.Button&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={() =&gt; setShowFooter(!showFooter)}&#10;          className={`toolbarButton${showFooter ? ' active' : ''}`}&#10;          title={showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;        &gt;&#10;          {showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;        &lt;/Toolbar.Button&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={handleAddSection}&#10;          className=&quot;toolbarButton&quot;&#10;          title=&quot;Section Ekle&quot;&#10;        &gt;&#10;          Section Ekle&#10;        &lt;/Toolbar.Button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Toolbar.Root&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/styles.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/styles.css" />
              <option name="originalContent" value="/* Çakışmasız ve taşma yapmayan A4 düzeni - DÜZELTİLDİ */&#10;.editor-a4-wrapper {&#10;  display: flex;&#10;  flex-direction: column;&#10;  align-items: center;&#10;  min-height: 100vh;&#10;  background: #f4f4f4;&#10;  padding: 40px 0;&#10;}&#10;&#10;.a4-page {&#10;  margin: 10px;&#10;  border: 1px solid #e5e7eb; /* subtle border */&#10;  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.06), 0 2px 6px rgba(0, 0, 0, 0.04);&#10;  overflow: hidden; /* ensure rounded corners clip children */&#10;  transition: box-shadow 180ms ease, border-color 180ms ease;&#10;}&#10;&#10;.toolbarRoot {&#10;  margin-bottom: 24px;&#10;  z-index: 10;&#10;}&#10;.a4-header {&#10;  /* 32mm ≈ 121px at 96dpi */&#10;  flex: 0 0 121px;&#10;  background: #f8fafc;&#10;  padding: 12px 24px;&#10;  font-weight: 600;&#10;  font-size: 20px;&#10;  color: #333;&#10;  box-sizing: border-box;&#10;  overflow: hidden; /* Taşmayı engelle */&#10;}&#10;&#10;.a4-content {&#10;  flex: 1 1 auto;&#10;  min-height: 0;&#10;  height: auto;&#10;  padding: 16px 24px 0 24px; /* alt boşluğu kaldır */&#10;  font-size: 16px;&#10;  line-height: 1.55;&#10;  color: #111827;&#10;  /* overflow: auto; kaldırıldı, scroll çıkmayacak */&#10;}&#10;&#10;/* Son elemanın aşağıda boşluk bırakmasını önle */&#10;.a4-content &gt; :last-child {&#10;  margin-bottom: 0 !important;&#10;}&#10;&#10;/* Lexical yapısında iç içe bloklar için de son elemanın boşluğunu kaldır */&#10;.a4-content p:last-child,&#10;.a4-content ul:last-child,&#10;.a4-content ol:last-child,&#10;.a4-content h1:last-child,&#10;.a4-content h2:last-child,&#10;.a4-content h3:last-child,&#10;.a4-content blockquote:last-child,&#10;.a4-content div:last-child {&#10;  margin-bottom: 0 !important;&#10;}&#10;&#10;/* İçerikteki son br (tarayıcı eklediği) görünmesin */&#10;.a4-content br:last-child {&#10;  display: none;&#10;}&#10;&#10;.a4-footer {&#10;  /* 20mm ≈ 76px at 96dpi */&#10;  flex: 0 0 76px;&#10;  background: #f8fafc;&#10;  border-top: 1px solid #e0e0e0;&#10;  padding: 8px 24px;&#10;  font-size: 16px;&#10;  color: #333;&#10;  box-sizing: border-box;&#10;  overflow: hidden; /* Taşmayı engelle */&#10;  align-items: center; /* tek satırı dikey hizala */&#10;  line-height: 1.2; /* satır kutusunu daralt */&#10;  margin-top: auto; /* Footer'ı her zaman en alta it */&#10;}&#10;&#10;/* Footer içindeki default margin'leri sıfırla */&#10;.a4-footer p,&#10;.a4-footer div {&#10;  margin: 0;&#10;}&#10;&#10;/* İçeriksizken oluşan son &lt;br&gt; satırını gizle */&#10;.a4-footer br:last-child {&#10;  display: none;&#10;}&#10;&#10;.editor-placeholder {&#10;  color: #bbb;&#10;  pointer-events: none;&#10;  font-size: 16px;&#10;  font-style: italic;&#10;}&#10;&#10;/* Contenteditable focus ring (header/footer edit modunda) */&#10;[contenteditable='true']:focus {&#10;  outline: 2px solid #1976d2;&#10;  outline-offset: 2px;&#10;}&#10;&#10;/* Selection styling inside page */&#10;.a4-page ::selection {&#10;  background: #dbeafe;&#10;  color: #111827;&#10;}&#10;&#10;/* Typography improvements inside content */&#10;.a4-content h1 {&#10;  font-size: 28px;&#10;  line-height: 1.25;&#10;  margin: 16px 0 8px;&#10;  font-weight: 700;&#10;}&#10;.a4-content h2 {&#10;  font-size: 24px;&#10;  line-height: 1.3;&#10;  margin: 14px 0 8px;&#10;  font-weight: 700;&#10;}&#10;.a4-content h3 {&#10;  font-size: 20px;&#10;  line-height: 1.35;&#10;  margin: 12px 0 6px;&#10;  font-weight: 700;&#10;}&#10;.a4-content p {&#10;  margin: 0 0 12px;&#10;}&#10;.a4-content ul,&#10;.a4-content ol {&#10;  margin: 0 0 12px 22px;&#10;}&#10;.a4-content a {&#10;  color: #1d4ed8;&#10;  text-decoration: underline;&#10;}&#10;.a4-content hr {&#10;  border: 0;&#10;  border-top: 1px solid #e5e7eb;&#10;  margin: 16px 0;&#10;}&#10;&#10;/* Subtle scrollbars for content area (webkit) */&#10;.a4-content::-webkit-scrollbar {&#10;  width: 10px;&#10;  height: 10px;&#10;}&#10;.a4-content::-webkit-scrollbar-thumb {&#10;  background: #c7d2fe;&#10;  border-radius: 8px;&#10;}&#10;.a4-content::-webkit-scrollbar-thumb:hover {&#10;  background: #a5b4fc;&#10;}&#10;.a4-content::-webkit-scrollbar-track {&#10;  background: transparent;&#10;}&#10;&#10;@media (max-width: 900px) {&#10;  .a4-page {&#10;    width: 100vw;&#10;    min-width: 0;&#10;    border-radius: 0;&#10;  }&#10;  .a4-header,&#10;  .a4-content,&#10;  .a4-footer {&#10;    padding-left: 12px;&#10;    padding-right: 12px;&#10;  }&#10;}&#10;&#10;/* Theme classes for text formatting */&#10;.editor-bold {&#10;  font-weight: 700;&#10;}&#10;.editor-italic {&#10;  font-style: italic;&#10;}&#10;.editor-underline {&#10;  text-decoration: underline;&#10;}&#10;&#10;.content-editable-disabled {&#10;  opacity: 0.6;&#10;  pointer-events: auto; /* Tıklama ile edit mode kapanabilsin diye */&#10;  user-select: none;&#10;  background: repeating-linear-gradient(135deg, #f5f5f5, #f5f5f5 10px, #e0e0e0 10px, #e0e0e0 20px);&#10;  transition: opacity 0.2s;&#10;}&#10;" />
              <option name="updatedContent" value="/* Çakışmasız ve taşma yapmayan A4 düzeni - DÜZELTİLDİ */&#10;.editor-a4-wrapper {&#10;  display: flex;&#10;  flex-direction: column;&#10;  align-items: center;&#10;  min-height: 100vh;&#10;  background: #f4f4f4;&#10;  padding: 40px 0;&#10;}&#10;&#10;.a4-page {&#10;  margin: 10px;&#10;  border: 1px solid #e5e7eb; /* subtle border */&#10;  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.06), 0 2px 6px rgba(0, 0, 0, 0.04);&#10;  overflow: hidden; /* ensure rounded corners clip children */&#10;  transition: box-shadow 180ms ease, border-color 180ms ease;&#10;}&#10;&#10;.toolbarRoot {&#10;  margin-bottom: 24px;&#10;  z-index: 10;&#10;}&#10;.a4-header {&#10;  /* 32mm ≈ 121px at 96dpi */&#10;  flex: 0 0 121px;&#10;  background: #f8fafc;&#10;  padding: 12px 24px;&#10;  font-weight: 600;&#10;  font-size: 20px;&#10;  color: #333;&#10;  box-sizing: border-box;&#10;  overflow: hidden; /* Taşmayı engelle */&#10;}&#10;&#10;.a4-content {&#10;  flex: 1 1 auto;&#10;  min-height: 0;&#10;  height: auto;&#10;  padding: 16px 24px 0 24px; /* alt boşluğu kaldır */&#10;  font-size: 16px;&#10;  line-height: 1.55;&#10;  color: #111827;&#10;  /* overflow: auto; kaldırıldı, scroll çıkmayacak */&#10;}&#10;&#10;/* Son elemanın aşağıda boşluk bırakmasını önle */&#10;.a4-content &gt; :last-child {&#10;  margin-bottom: 0 !important;&#10;}&#10;&#10;/* Lexical yapısında iç içe bloklar için de son elemanın boşluğunu kaldır */&#10;.a4-content p:last-child,&#10;.a4-content ul:last-child,&#10;.a4-content ol:last-child,&#10;.a4-content h1:last-child,&#10;.a4-content h2:last-child,&#10;.a4-content h3:last-child,&#10;.a4-content blockquote:last-child,&#10;.a4-content div:last-child {&#10;  margin-bottom: 0 !important;&#10;}&#10;&#10;/* İçerikteki son br (tarayıcı eklediği) görünmesin */&#10;.a4-content br:last-child {&#10;  display: none;&#10;}&#10;&#10;.a4-footer {&#10;  /* 20mm ≈ 76px at 96dpi */&#10;  flex: 0 0 76px;&#10;  background: #f8fafc;&#10;  border-top: 1px solid #e0e0e0;&#10;  padding: 8px 24px;&#10;  font-size: 16px;&#10;  color: #333;&#10;  box-sizing: border-box;&#10;  overflow: hidden; /* Taşmayı engelle */&#10;  align-items: center; /* tek satırı dikey hizala */&#10;  line-height: 1.2; /* satır kutusunu daralt */&#10;  margin-top: auto; /* Footer'ı her zaman en alta it */&#10;}&#10;&#10;/* Footer içindeki default margin'leri sıfırla */&#10;.a4-footer p,&#10;.a4-footer div {&#10;  margin: 0;&#10;}&#10;&#10;/* İçeriksizken oluşan son &lt;br&gt; satırını gizle */&#10;.a4-footer br:last-child {&#10;  display: none;&#10;}&#10;&#10;.editor-placeholder {&#10;  color: #bbb;&#10;  pointer-events: none;&#10;  font-size: 16px;&#10;  font-style: italic;&#10;}&#10;&#10;/* Contenteditable focus ring (header/footer edit modunda) */&#10;[contenteditable='true']:focus {&#10;  outline: 2px solid #1976d2;&#10;  outline-offset: 2px;&#10;}&#10;&#10;/* Selection styling inside page */&#10;.a4-page ::selection {&#10;  background: #dbeafe;&#10;  color: #111827;&#10;}&#10;&#10;/* Typography improvements inside content */&#10;.a4-content h1 {&#10;  font-size: 28px;&#10;  line-height: 1.25;&#10;  margin: 16px 0 8px;&#10;  font-weight: 700;&#10;}&#10;.a4-content h2 {&#10;  font-size: 24px;&#10;  line-height: 1.3;&#10;  margin: 14px 0 8px;&#10;  font-weight: 700;&#10;}&#10;.a4-content h3 {&#10;  font-size: 20px;&#10;  line-height: 1.35;&#10;  margin: 12px 0 6px;&#10;  font-weight: 700;&#10;}&#10;.a4-content p {&#10;  margin: 0 0 12px;&#10;}&#10;.a4-content ul,&#10;.a4-content ol {&#10;  margin: 0 0 12px 22px;&#10;}&#10;.a4-content a {&#10;  color: #1d4ed8;&#10;  text-decoration: underline;&#10;}&#10;.a4-content hr {&#10;  border: 0;&#10;  border-top: 1px solid #e5e7eb;&#10;  margin: 16px 0;&#10;}&#10;&#10;/* Subtle scrollbars for content area (webkit) */&#10;.a4-content::-webkit-scrollbar {&#10;  width: 10px;&#10;  height: 10px;&#10;}&#10;.a4-content::-webkit-scrollbar-thumb {&#10;  background: #c7d2fe;&#10;  border-radius: 8px;&#10;}&#10;.a4-content::-webkit-scrollbar-thumb:hover {&#10;  background: #a5b4fc;&#10;}&#10;.a4-content::-webkit-scrollbar-track {&#10;  background: transparent;&#10;}&#10;&#10;@media (max-width: 900px) {&#10;  .a4-page {&#10;    width: 100vw;&#10;    min-width: 0;&#10;    border-radius: 0;&#10;  }&#10;  .a4-header,&#10;  .a4-content,&#10;  .a4-footer {&#10;    padding-left: 12px;&#10;    padding-right: 12px;&#10;  }&#10;}&#10;&#10;/* Theme classes for text formatting */&#10;.editor-bold {&#10;  font-weight: 700;&#10;}&#10;.editor-italic {&#10;  font-style: italic;&#10;}&#10;.editor-underline {&#10;  text-decoration: underline;&#10;}&#10;&#10;/* .content-editable-disabled {&#10;  opacity: 0.6;&#10;  pointer-events: auto; &#10;  user-select: none;&#10;  background: repeating-linear-gradient(135deg, #f5f5f5, #f5f5f5 10px, #e0e0e0 10px, #e0e0e0 20px);&#10;  transition: opacity 0.2s;&#10;} */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import {&#10;  DEFAULT_PAGINATION_SETTINGS,&#10;  type PaginationSettings&#10;} from './plugins/pagination/PaginationSettings';&#10;import { PageBreakNode } from './plugins/pagination/PageBreakNode';&#10;import { WordCountPlugin } from './plugins/WordCountPlugin';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import './styles.css';&#10;import { BannerNode, BannerPlugin } from './plugins/banner/BannerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;export default function Editor({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): JSX.Element {&#10;  const [pageCount, setPageCount] = React.useState(1);&#10;  const paginationSettings: PaginationSettings = DEFAULT_PAGINATION_SETTINGS;&#10;&#10;  const handlePageCountChange = React.useCallback((count: number) =&gt; {&#10;    setPageCount(count);&#10;  }, []);&#10;&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [PageBreakNode, BannerNode]&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-container paginated&quot;&gt;&#10;      &lt;div className=&quot;page-indicator&quot;&gt;Page {pageCount}&lt;/div&gt;&#10;      &lt;div&#10;        className=&quot;a4-page&quot;&#10;        style={{&#10;          width: `${paginationSettings.pageWidth}mm`,&#10;          minHeight: `${paginationSettings.pageHeight}mm`,&#10;          margin: `${paginationSettings.marginTop}mm ${paginationSettings.marginRight}mm ${paginationSettings.marginBottom}mm ${paginationSettings.marginLeft}mm`&#10;        }}&#10;      &gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;ToolbarPlugin /&gt;&#10;          &lt;BannerPlugin /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;            placeholder={&lt;div className=&quot;placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;PaginationPlugin&#10;            settings={paginationSettings}&#10;            onPageCountChange={handlePageCountChange}&#10;          /&gt;&#10;          &lt;WordCountPlugin onWordCountChange={onWordCountChange} /&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { PaginationPlugin } from './plugins/pagination/PaginationPlugin';&#10;import { DEFAULT_PAGINATION_SETTINGS, type PaginationSettings } from './plugins/pagination/PaginationSettings';&#10;import { PageBreakNode } from './plugins/pagination/PageBreakNode';&#10;import { WordCountPlugin } from './plugins/WordCountPlugin';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import './styles.css';&#10;import { BannerNode, BannerPlugin } from './plugins/banner/BannerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;export default function Editor({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): JSX.Element {&#10;  const [pageCount, setPageCount] = React.useState(1);&#10;  const paginationSettings: PaginationSettings = DEFAULT_PAGINATION_SETTINGS;&#10;&#10;  const handlePageCountChange = React.useCallback((count: number) =&gt; {&#10;    setPageCount(count);&#10;  }, []);&#10;&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [PageBreakNode, BannerNode]&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-container paginated&quot;&gt;&#10;      &lt;div className=&quot;page-indicator&quot;&gt;Page {pageCount}&lt;/div&gt;&#10;      &lt;div&#10;        className=&quot;a4-page&quot;&#10;        style={{&#10;          width: `${paginationSettings.pageWidth}mm`,&#10;          minHeight: `${paginationSettings.pageHeight}mm`,&#10;          margin: `${paginationSettings.marginTop}mm ${paginationSettings.marginRight}mm ${paginationSettings.marginBottom}mm ${paginationSettings.marginLeft}mm`&#10;        }}&#10;      &gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;ToolbarPlugin /&gt;&#10;          &lt;BannerPlugin /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;            placeholder={&lt;div className=&quot;placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;PaginationPlugin&#10;            settings={paginationSettings}&#10;            onPageCountChange={handlePageCountChange}&#10;          /&gt;&#10;          &lt;WordCountPlugin onWordCountChange={onWordCountChange} /&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/WordCountPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/WordCountPlugin.tsx" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEffect } from 'react';&#10;import { $getRoot } from 'lexical';&#10;&#10;export function WordCountPlugin({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(() =&gt; {&#10;      editor.getEditorState().read(() =&gt; {&#10;        const text = $getRoot().getTextContent();&#10;        const words = text.trim().split(/\s+/).filter((word) =&gt; word.length &gt; 0).length;&#10;        const chars = text.length;&#10;        onWordCountChange?.(words, chars);&#10;      });&#10;    });&#10;  }, [editor, onWordCountChange]);&#10;&#10;  return null;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, type PageBreakNode } from './PageBreakNode';&#10;&#10;export interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;export const DEFAULT_PAGINATION_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210, // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20&#10;};&#10;&#10;export const PAGINATION_PRESETS: Record&lt;string, Partial&lt;PaginationSettings&gt;&gt; = {&#10;  A4: { pageWidth: 210, pageHeight: 297 },&#10;  A3: { pageWidth: 297, pageHeight: 420 },&#10;  Letter: { pageWidth: 216, pageHeight: 279 },&#10;  Legal: { pageWidth: 216, pageHeight: 356 }&#10;};&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_PAGINATION_SETTINGS,&#10;  onPageCountChange&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const finalSettings = { ...DEFAULT_PAGINATION_SETTINGS, ...settings };&#10;  const contentHeight =&#10;    finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: Array&lt;{ index: number; pageNumber: number }&gt; = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Collect existing page breaks&#10;      children.forEach((child) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach((pageBreak) =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element !== null) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const nodeAtIndex = root.getChildAtIndex(index);&#10;        if (nodeAtIndex !== null) {&#10;          const pageBreak = $createPageBreakNode(pageNumber);&#10;          nodeAtIndex.insertBefore(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      onPageCountChange?.(newPageCount);&#10;    });&#10;  }, [editor, contentHeight, onPageCountChange]);&#10;&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; {&#10;      clearTimeout(timer);&#10;    };&#10;  }, [checkForPageBreak]);&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ dirtyElements, dirtyLeaves }) =&gt; {&#10;      if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;        setTimeout(() =&gt; {&#10;          checkForPageBreak();&#10;        }, 100);&#10;      }&#10;    });&#10;  }, [editor, checkForPageBreak]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, type PageBreakNode } from './PageBreakNode';&#10;import { PaginationSettings, DEFAULT_PAGINATION_SETTINGS, PAGINATION_PRESETS } from './PaginationSettings';&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_PAGINATION_SETTINGS,&#10;  onPageCountChange&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const finalSettings = { ...DEFAULT_PAGINATION_SETTINGS, ...settings };&#10;  const contentHeight =&#10;    finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: Array&lt;{ index: number; pageNumber: number }&gt; = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Collect existing page breaks&#10;      children.forEach((child) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach((pageBreak) =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element !== null) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const nodeAtIndex = root.getChildAtIndex(index);&#10;        if (nodeAtIndex !== null) {&#10;          const pageBreak = $createPageBreakNode(pageNumber);&#10;          nodeAtIndex.insertBefore(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      onPageCountChange?.(newPageCount);&#10;    });&#10;  }, [editor, contentHeight, onPageCountChange]);&#10;&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; {&#10;      clearTimeout(timer);&#10;    };&#10;  }, [checkForPageBreak]);&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ dirtyElements, dirtyLeaves }) =&gt; {&#10;      if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;        setTimeout(() =&gt; {&#10;          checkForPageBreak();&#10;        }, 100);&#10;      }&#10;    });&#10;  }, [editor, checkForPageBreak]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettingsPanel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettingsPanel.tsx" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import type { PaginationSettings } from './PaginationPlugin';&#10;&#10;interface PaginationSettingsProps {&#10;  settings: PaginationSettings;&#10;  onSettingsChange: (settings: PaginationSettings) =&gt; void;&#10;  isVisible: boolean;&#10;  onToggle: () =&gt; void;&#10;}&#10;&#10;export function PaginationSettingsPanel({&#10;  settings,&#10;  onSettingsChange,&#10;  isVisible,&#10;  onToggle&#10;}: PaginationSettingsProps): JSX.Element {&#10;  const [localSettings, setLocalSettings] = useState(settings);&#10;&#10;  const handleChange = (field: keyof PaginationSettings, value: number): void =&gt; {&#10;    const newSettings = { ...localSettings, [field]: value };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  const presets = {&#10;    A4: { pageWidth: 210, pageHeight: 297 },&#10;    A3: { pageWidth: 297, pageHeight: 420 },&#10;    Letter: { pageWidth: 216, pageHeight: 279 },&#10;    Legal: { pageWidth: 216, pageHeight: 356 }&#10;  };&#10;&#10;  const applyPreset = (preset: keyof typeof presets): void =&gt; {&#10;    const newSettings = {&#10;      ...localSettings,&#10;      ...presets[preset]&#10;    };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  if (!isVisible) {&#10;    return (&#10;      &lt;button className=&quot;pagination-control-btn settings-toggle&quot; onClick={onToggle}&gt;&#10;        ⚙️&#10;      &lt;/button&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;page-settings&quot;&gt;&#10;      &lt;div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}&gt;&#10;        &lt;h3&gt;Sayfa Ayarları&lt;/h3&gt;&#10;        &lt;button&#10;          onClick={onToggle}&#10;          style={{&#10;            background: 'none',&#10;            border: 'none',&#10;            cursor: 'pointer',&#10;            fontSize: '16px'&#10;          }}&#10;        &gt;&#10;          ✕&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div style={{ marginBottom: '12px' }}&gt;&#10;        &lt;label&gt;Sayfa Boyutu Önayarları:&lt;/label&gt;&#10;        &lt;div style={{ display: 'flex', gap: '4px', marginTop: '4px' }}&gt;&#10;          {Object.keys(presets).map((preset) =&gt; (&#10;            &lt;button&#10;              key={preset}&#10;              onClick={() =&gt; {&#10;                applyPreset(preset as keyof typeof presets);&#10;              }}&#10;              style={{&#10;                padding: '4px 8px',&#10;                border: '1px solid #d1d1d1',&#10;                borderRadius: '2px',&#10;                background: 'white',&#10;                cursor: 'pointer',&#10;                fontSize: '10px'&#10;              }}&#10;            &gt;&#10;              {preset}&#10;            &lt;/button&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;label&gt;&#10;        Genişlik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageWidth}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageWidth', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;500&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Yükseklik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageHeight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageHeight', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;700&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Üst Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginTop}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginTop', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Alt Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginBottom}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginBottom', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sol Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginLeft}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginLeft', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sağ Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginRight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginRight', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;div style={{ marginTop: '12px', fontSize: '10px', color: '#666' }}&gt;&#10;        Ctrl+Enter: Yeni sayfa ekle&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="export interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;export const DEFAULT_PAGINATION_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210,  // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20&#10;};&#10;&#10;export const PAGINATION_PRESETS: Record&lt;string, Partial&lt;PaginationSettings&gt;&gt; = {&#10;  A4: { pageWidth: 210, pageHeight: 297 },&#10;  A3: { pageWidth: 297, pageHeight: 420 },&#10;  Letter: { pageWidth: 216, pageHeight: 279 },&#10;  Legal: { pageWidth: 216, pageHeight: 356 }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/toolbar/Toolbar.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/toolbar/Toolbar.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $setBlocksType_experimental } from '@lexical/selection';&#10;import { $isRangeSelection, $getSelection, type TextFormatType, $getRoot } from 'lexical';&#10;import { $createHeadingNode } from '@lexical/rich-text';&#10;import { INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND } from '@lexical/list';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;import {&#10;  StrikethroughIcon,&#10;  FontBoldIcon,&#10;  FontItalicIcon,&#10;  UnderlineIcon&#10;} from '@radix-ui/react-icons';&#10;import { OrderedListIcon, UnorderedListIcon } from './icons';&#10;import './Toolbar.css';&#10;import type { PageNode } from '../editor/nodes/PageNode';&#10;&#10;interface ToolbarPluginProps {&#10;  headerFooterEditMode: boolean;&#10;  setHeaderFooterEditMode: (v: boolean) =&gt; void;&#10;}&#10;&#10;interface ToolbarButtonProps {&#10;  className?: string;&#10;  onClick?: () =&gt; void;&#10;  title?: string;&#10;  children: React.ReactNode;&#10;  disabled?: boolean;&#10;}&#10;&#10;function ToolbarButton(props: ToolbarButtonProps): JSX.Element {&#10;  const { className, onClick, title, children, disabled, ...rest } = props;&#10;  return (&#10;    &lt;Toolbar.Button&#10;      className={`toolbarButton ${className ?? ''}`}&#10;      onClick={onClick}&#10;      title={title}&#10;      disabled={disabled}&#10;      {...rest}&#10;    &gt;&#10;      {children}&#10;    &lt;/Toolbar.Button&gt;&#10;  );&#10;}&#10;&#10;function TextFormatToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const getIcon = (format: TextFormatType): JSX.Element | null =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return &lt;FontBoldIcon /&gt;;&#10;      case 'italic':&#10;        return &lt;FontItalicIcon /&gt;;&#10;      case 'strikethrough':&#10;        return &lt;StrikethroughIcon /&gt;;&#10;      case 'underline':&#10;        return &lt;UnderlineIcon /&gt;;&#10;      default:&#10;        return null;&#10;    }&#10;  };&#10;&#10;  const getTitle = (format: TextFormatType): string =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return 'Kalın (Ctrl+B)';&#10;      case 'italic':&#10;        return 'İtalik (Ctrl+I)';&#10;      case 'underline':&#10;        return 'Alt çizgi (Ctrl+U)';&#10;      case 'strikethrough':&#10;        return 'Üstü çizili';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (format: TextFormatType): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        selection.formatText(format);&#10;      }&#10;    });&#10;  };&#10;&#10;  const supportedTextFormats: TextFormatType[] = ['bold', 'italic', 'underline', 'strikethrough'];&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {supportedTextFormats.map((format) =&gt; (&#10;        &lt;ToolbarButton&#10;          key={format}&#10;          onClick={() =&gt; {&#10;            onClick(format);&#10;          }}&#10;          title={getTitle(format)}&#10;          data-format&#10;        &gt;&#10;          {getIcon(format)}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;type HeadingTag = 'h1' | 'h2' | 'h3';&#10;function HeadingToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const headingTags: HeadingTag[] = ['h1', 'h2', 'h3'];&#10;&#10;  const getTitle = (tag: HeadingTag): string =&gt; {&#10;    switch (tag) {&#10;      case 'h1':&#10;        return 'Başlık 1';&#10;      case 'h2':&#10;        return 'Başlık 2';&#10;      case 'h3':&#10;        return 'Başlık 3';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (tag: HeadingTag): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        $setBlocksType_experimental(selection, () =&gt; $createHeadingNode(tag) as any);&#10;      }&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {headingTags.map((tag) =&gt; (&#10;        &lt;ToolbarButton&#10;          onClick={() =&gt; {&#10;            onClick(tag);&#10;          }}&#10;          key={tag}&#10;          title={getTitle(tag)}&#10;          data-heading&#10;        &gt;&#10;          {tag.toUpperCase()}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;function ListToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const onClick = (tag: 'ol' | 'ul'): void =&gt; {&#10;    if (tag === 'ol') {&#10;      editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined);&#10;      return;&#10;    }&#10;    editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ol');&#10;        }}&#10;        title=&quot;Numaralı liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;OrderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ul');&#10;        }}&#10;        title=&quot;Madde işaretli liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;UnorderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;// Tek bir plugin: PageSectionPlugin (adlandırma güncellendi)&#10;function PageSectionPlugin({&#10;  headerFooterEditMode,&#10;  setHeaderFooterEditMode&#10;}: ToolbarPluginProps): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  const handleHeader = (): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const pageNode = root&#10;        .getChildren()&#10;        .find(&#10;          (n) =&gt; typeof (n as any).getType === 'function' &amp;&amp; (n as any).getType() === 'page'&#10;        ) as PageNode | undefined;&#10;      if (pageNode == null) return;&#10;      const headerNode = pageNode.getHeaderNode();&#10;      if (headerNode == null) return;&#10;      headerNode.setVisible(!headerNode.isVisible());&#10;    });&#10;  };&#10;  const handleFooter = (): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const pageNode = root&#10;        .getChildren()&#10;        .find(&#10;          (n) =&gt; typeof (n as any).getType === 'function' &amp;&amp; (n as any).getType() === 'page'&#10;        ) as PageNode | undefined;&#10;      if (pageNode == null) return;&#10;      const footerNode = pageNode.getFooterNode();&#10;      if (footerNode == null) return;&#10;      footerNode.setVisible(!footerNode.isVisible());&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          setHeaderFooterEditMode(!headerFooterEditMode);&#10;        }}&#10;        title=&quot;Header/Footer Düzenle&quot;&#10;      &gt;&#10;        {headerFooterEditMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;      &lt;/ToolbarButton&gt;&#10;      {headerFooterEditMode &amp;&amp; (&#10;        &lt;&gt;&#10;          &lt;ToolbarButton onClick={handleHeader} title=&quot;Header Ekle/Kaldır&quot;&gt;&#10;            Header Ekle/Kaldır&#10;          &lt;/ToolbarButton&gt;&#10;          &lt;ToolbarButton onClick={handleFooter} title=&quot;Footer Ekle/Kaldır&quot;&gt;&#10;            Footer Ekle/Kaldır&#10;          &lt;/ToolbarButton&gt;&#10;        &lt;/&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export function ToolbarPlugin({&#10;  headerFooterEditMode,&#10;  setHeaderFooterEditMode&#10;}: ToolbarPluginProps): JSX.Element {&#10;  return (&#10;    &lt;Toolbar.Root className=&quot;toolbarRoot&quot;&gt;&#10;      &lt;TextFormatToolbarPlugin /&gt;&#10;      &lt;HeadingToolbarPlugin /&gt;&#10;      &lt;ListToolbarPlugin /&gt;&#10;      &lt;PageSectionPlugin&#10;        headerFooterEditMode={headerFooterEditMode}&#10;        setHeaderFooterEditMode={setHeaderFooterEditMode}&#10;      /&gt;&#10;    &lt;/Toolbar.Root&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $setBlocksType_experimental } from '@lexical/selection';&#10;import { $isRangeSelection, $getSelection, type TextFormatType, $getRoot } from 'lexical';&#10;import { $createHeadingNode } from '@lexical/rich-text';&#10;import { INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND } from '@lexical/list';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;import {&#10;  StrikethroughIcon,&#10;  FontBoldIcon,&#10;  FontItalicIcon,&#10;  UnderlineIcon&#10;} from '@radix-ui/react-icons';&#10;import { OrderedListIcon, UnorderedListIcon } from './icons';&#10;import './Toolbar.css';&#10;import type { PageNode } from '../editor/nodes/PageNode';&#10;&#10;interface ToolbarPluginProps {&#10;  headerFooterEditMode: boolean;&#10;  setHeaderFooterEditMode: (v: boolean) =&gt; void;&#10;}&#10;&#10;interface ToolbarButtonProps {&#10;  className?: string;&#10;  onClick?: () =&gt; void;&#10;  title?: string;&#10;  children: React.ReactNode;&#10;  disabled?: boolean;&#10;}&#10;&#10;function ToolbarButton(props: ToolbarButtonProps): JSX.Element {&#10;  const { className, onClick, title, children, disabled, ...rest } = props;&#10;  return (&#10;    &lt;Toolbar.Button&#10;      className={`toolbarButton ${className ?? ''}`}&#10;      onClick={onClick}&#10;      title={title}&#10;      disabled={disabled}&#10;      {...rest}&#10;    &gt;&#10;      {children}&#10;    &lt;/Toolbar.Button&gt;&#10;  );&#10;}&#10;&#10;function TextFormatToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const getIcon = (format: TextFormatType): JSX.Element | null =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return &lt;FontBoldIcon /&gt;;&#10;      case 'italic':&#10;        return &lt;FontItalicIcon /&gt;;&#10;      case 'strikethrough':&#10;        return &lt;StrikethroughIcon /&gt;;&#10;      case 'underline':&#10;        return &lt;UnderlineIcon /&gt;;&#10;      default:&#10;        return null;&#10;    }&#10;  };&#10;&#10;  const getTitle = (format: TextFormatType): string =&gt; {&#10;    switch (format) {&#10;      case 'bold':&#10;        return 'Kalın (Ctrl+B)';&#10;      case 'italic':&#10;        return 'İtalik (Ctrl+I)';&#10;      case 'underline':&#10;        return 'Alt çizgi (Ctrl+U)';&#10;      case 'strikethrough':&#10;        return 'Üstü çizili';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (format: TextFormatType): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        selection.formatText(format);&#10;      }&#10;    });&#10;  };&#10;&#10;  const supportedTextFormats: TextFormatType[] = ['bold', 'italic', 'underline', 'strikethrough'];&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {supportedTextFormats.map((format) =&gt; (&#10;        &lt;ToolbarButton&#10;          key={format}&#10;          onClick={() =&gt; {&#10;            onClick(format);&#10;          }}&#10;          title={getTitle(format)}&#10;          data-format&#10;        &gt;&#10;          {getIcon(format)}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;type HeadingTag = 'h1' | 'h2' | 'h3';&#10;function HeadingToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const headingTags: HeadingTag[] = ['h1', 'h2', 'h3'];&#10;&#10;  const getTitle = (tag: HeadingTag): string =&gt; {&#10;    switch (tag) {&#10;      case 'h1':&#10;        return 'Başlık 1';&#10;      case 'h2':&#10;        return 'Başlık 2';&#10;      case 'h3':&#10;        return 'Başlık 3';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  const onClick = (tag: HeadingTag): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        $setBlocksType_experimental(selection, () =&gt; $createHeadingNode(tag) as any);&#10;      }&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      {headingTags.map((tag) =&gt; (&#10;        &lt;ToolbarButton&#10;          onClick={() =&gt; {&#10;            onClick(tag);&#10;          }}&#10;          key={tag}&#10;          title={getTitle(tag)}&#10;          data-heading&#10;        &gt;&#10;          {tag.toUpperCase()}&#10;        &lt;/ToolbarButton&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;function ListToolbarPlugin(): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;  const onClick = (tag: 'ol' | 'ul'): void =&gt; {&#10;    if (tag === 'ol') {&#10;      editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined);&#10;      return;&#10;    }&#10;    editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ol');&#10;        }}&#10;        title=&quot;Numaralı liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;OrderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          onClick('ul');&#10;        }}&#10;        title=&quot;Madde işaretli liste&quot;&#10;        data-list&#10;      &gt;&#10;        &lt;UnorderedListIcon /&gt;&#10;      &lt;/ToolbarButton&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;// Tek bir plugin: PageSectionPlugin (adlandırma güncellendi)&#10;function PageSectionPlugin({&#10;  headerFooterEditMode,&#10;  setHeaderFooterEditMode&#10;}: ToolbarPluginProps): JSX.Element {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  const handleHeader = (): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      // Tüm sayfalardaki PageNode'ları bul&#10;      const pageNodes = root.getChildren().filter(&#10;        (n) =&gt; typeof (n as any).getType === 'function' &amp;&amp; (n as any).getType() === 'page'&#10;      ) as PageNode[];&#10;      pageNodes.forEach((pageNode) =&gt; {&#10;        // Header yoksa ekle&#10;        if (typeof pageNode.ensureHeaderFooterContentChildren === 'function') {&#10;          pageNode.ensureHeaderFooterContentChildren();&#10;        }&#10;        const headerNode = pageNode.getHeaderNode();&#10;        if (headerNode == null) return;&#10;        headerNode.setVisible(!headerNode.isVisible());&#10;      });&#10;    });&#10;  };&#10;  const handleFooter = (): void =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      // Tüm sayfalardaki PageNode'ları bul&#10;      const pageNodes = root.getChildren().filter(&#10;        (n) =&gt; typeof (n as any).getType === 'function' &amp;&amp; (n as any).getType() === 'page'&#10;      ) as PageNode[];&#10;      pageNodes.forEach((pageNode) =&gt; {&#10;        // Footer yoksa ekle&#10;        if (typeof pageNode.ensureHeaderFooterContentChildren === 'function') {&#10;          pageNode.ensureHeaderFooterContentChildren();&#10;        }&#10;        const footerNode = pageNode.getFooterNode();&#10;        if (footerNode == null) return;&#10;        footerNode.setVisible(!footerNode.isVisible());&#10;      });&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;ToolbarButton&#10;        onClick={() =&gt; {&#10;          setHeaderFooterEditMode(!headerFooterEditMode);&#10;        }}&#10;        title=&quot;Header/Footer Düzenle&quot;&#10;      &gt;&#10;        {headerFooterEditMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;      &lt;/ToolbarButton&gt;&#10;      {headerFooterEditMode &amp;&amp; (&#10;        &lt;&gt;&#10;          &lt;ToolbarButton onClick={handleHeader} title=&quot;Header Ekle/Kaldır&quot;&gt;&#10;            Header Ekle/Kaldır&#10;          &lt;/ToolbarButton&gt;&#10;          &lt;ToolbarButton onClick={handleFooter} title=&quot;Footer Ekle/Kaldır&quot;&gt;&#10;            Footer Ekle/Kaldır&#10;          &lt;/ToolbarButton&gt;&#10;        &lt;/&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export function ToolbarPlugin({&#10;  headerFooterEditMode,&#10;  setHeaderFooterEditMode&#10;}: ToolbarPluginProps): JSX.Element {&#10;  return (&#10;    &lt;Toolbar.Root className=&quot;toolbarRoot&quot;&gt;&#10;      &lt;TextFormatToolbarPlugin /&gt;&#10;      &lt;HeadingToolbarPlugin /&gt;&#10;      &lt;ListToolbarPlugin /&gt;&#10;      &lt;PageSectionPlugin&#10;        headerFooterEditMode={headerFooterEditMode}&#10;        setHeaderFooterEditMode={setHeaderFooterEditMode}&#10;      /&gt;&#10;    &lt;/Toolbar.Root&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>