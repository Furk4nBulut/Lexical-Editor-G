<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/editor/nodes/SectionNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/nodes/SectionNode.tsx" />
              <option name="updatedContent" value="import { ElementNode, SerializedElementNode, EditorConfig, Spread } from 'lexical';&#10;import * as React from 'react';&#10;&#10;export type SerializedSectionNode = Spread&lt;&#10;  {&#10;    type: 'section';&#10;    version: 1;&#10;  },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;export class SectionNode extends ElementNode {&#10;  static getType(): string {&#10;    return 'section';&#10;  }&#10;&#10;  static clone(node: SectionNode): SectionNode {&#10;    return new SectionNode(node.__key);&#10;  }&#10;&#10;  createDOM(_config: EditorConfig): HTMLElement {&#10;    const dom = document.createElement('section');&#10;    dom.className = 'a4-section';&#10;    return dom;&#10;  }&#10;&#10;  updateDOM(): boolean {&#10;    return false;&#10;  }&#10;&#10;  static importJSON(_serializedNode: SerializedSectionNode): SectionNode {&#10;    return new SectionNode();&#10;  }&#10;&#10;  exportJSON(): SerializedSectionNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      type: 'section',&#10;      version: 1,&#10;    };&#10;  }&#10;&#10;  decorate(): JSX.Element | null {&#10;    return null;&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/PageAutoSplitPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/PageAutoSplitPlugin.tsx" />
              <option name="originalContent" value="import { useEffect, useRef } from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import {&#10;  $getRoot,&#10;  $getSelection,&#10;  $isRangeSelection,&#10;  $isTextNode,&#10;  $createTextNode,&#10;  $createParagraphNode&#10;} from 'lexical';&#10;import type { ElementNode as LexicalElementNode } from 'lexical';&#10;import { $createPageNode, $isPageNode, type PageNode } from '../nodes/PageNode';&#10;import { isContentNode, isHeaderNode, isFooterNode } from '../nodes/sectionTypeGuards';&#10;import { PageHeaderNode } from '../nodes/PageHeaderNode';&#10;import { PageFooterNode } from '../nodes/PageFooterNode';&#10;import { PageContentNode } from '../nodes/PageContentNode';&#10;&#10;export interface PageFlowSettings {&#10;  pageHeightMm: number;&#10;  marginTopMm: number;&#10;  marginBottomMm: number;&#10;}&#10;&#10;export function PageAutoSplitPlugin({&#10;  pageHeightMm,&#10;  marginTopMm,&#10;  marginBottomMm&#10;}: PageFlowSettings): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const rafRef = useRef&lt;number | null&gt;(null);&#10;  const isReflowingRef = useRef(false);&#10;  const unbreakableTooTallKeysRef = useRef&lt;Set&lt;string&gt;&gt;(new Set());&#10;&#10;  useEffect(() =&gt; {&#10;    function getPageEl(page: PageNode): HTMLElement | null {&#10;      return editor.getElementByKey(page.getKey());&#10;    }&#10;&#10;    function getContentMetrics(pageEl: HTMLElement): {&#10;      el: HTMLElement | null;&#10;      top: number;&#10;      bottom: number;&#10;      height: number;&#10;      paddingTop: number;&#10;      paddingBottom: number;&#10;    } {&#10;      const el = pageEl.querySelector('[data-lexical-page-section=&quot;content&quot;]');&#10;      const contentEl = el instanceof HTMLElement ? el : null;&#10;      const target = contentEl ?? pageEl;&#10;      const rect = target.getBoundingClientRect();&#10;      const styles = window.getComputedStyle(target);&#10;      let paddingTop = parseFloat(styles.paddingTop);&#10;      let paddingBottom = parseFloat(styles.paddingBottom);&#10;      if (Number.isNaN(paddingTop)) paddingTop = 0;&#10;      if (Number.isNaN(paddingBottom)) paddingBottom = 0;&#10;      const top = rect.top + paddingTop;&#10;      const bottom = rect.bottom - paddingBottom;&#10;      return { el: contentEl, top, bottom, height: bottom - top, paddingTop, paddingBottom };&#10;    }&#10;&#10;    function getContentScrollHeight(&#10;      targetEl: HTMLElement,&#10;      paddingTop: number,&#10;      paddingBottom: number&#10;    ): number {&#10;      return targetEl.scrollHeight - paddingTop - paddingBottom;&#10;    }&#10;&#10;    function proportionalSplitParagraphByHeight(&#10;      block: LexicalElementNode,&#10;      currentHeightPx: number,&#10;      targetHeightPx: number&#10;    ): boolean {&#10;      const textNodes = block.getChildren().filter($isTextNode);&#10;      if (textNodes.length === 0) return false;&#10;      const totalChars = textNodes.reduce((sum, t) =&gt; sum + t.getTextContent().length, 0);&#10;      if (totalChars &lt; 2) return false;&#10;      const keepChars = Math.max(&#10;        1,&#10;        Math.min(totalChars - 1, Math.floor((targetHeightPx / currentHeightPx) * totalChars))&#10;      );&#10;      let remainingToKeep = keepChars;&#10;      const newPara = $createParagraphNode();&#10;      const movedNodes: Array&lt;ReturnType&lt;typeof $createTextNode&gt;&gt; = [];&#10;      for (const t of textNodes) {&#10;        if (remainingToKeep &lt;= 0) {&#10;          movedNodes.push($createTextNode(t.getTextContent()));&#10;          t.remove();&#10;          continue;&#10;        }&#10;        const text = t.getTextContent();&#10;        if (text.length &lt;= remainingToKeep) {&#10;          remainingToKeep -= text.length;&#10;          continue;&#10;        }&#10;        const left = text.slice(0, remainingToKeep);&#10;        const right = text.slice(remainingToKeep);&#10;        t.setTextContent(left);&#10;        movedNodes.push($createTextNode(right));&#10;        remainingToKeep = 0;&#10;      }&#10;      if (movedNodes.length === 0) return false;&#10;      movedNodes.forEach((n) =&gt; newPara.append(n));&#10;      block.insertAfter(newPara);&#10;      return true;&#10;    }&#10;&#10;    function pickMovableBlock(blocks: LexicalElementNode[]): LexicalElementNode | null {&#10;      for (let i = blocks.length - 1; i &gt;= 0; i--) {&#10;        const node = blocks[i];&#10;        const el = editor.getElementByKey(node.getKey());&#10;        const height = el?.offsetHeight ?? 0;&#10;        const textGetter = (node as unknown as { getTextContent?: () =&gt; string }).getTextContent;&#10;        const text = typeof textGetter === 'function' ? textGetter.call(node) : '';&#10;        if ((text?.trim()?.length ?? 0) &gt; 0 || height &gt; 2) {&#10;          return node;&#10;        }&#10;      }&#10;      return blocks.length &gt; 0 ? blocks[blocks.length - 1] : null;&#10;    }&#10;&#10;    function reflowPass(): boolean {&#10;      let didMoveAny = false;&#10;&#10;      editor.update(() =&gt; {&#10;        const root = $getRoot();&#10;        if (root.getChildrenSize() === 0) {&#10;          root.append($createPageNode());&#10;          return;&#10;        }&#10;&#10;        const children = root.getChildren();&#10;        const hasNonPage = children.some((n) =&gt; !$isPageNode(n));&#10;        if (hasNonPage) {&#10;          const page = $createPageNode();&#10;          children.forEach((n) =&gt; {&#10;            if (!$isPageNode(n)) {&#10;              // Move foreign nodes into first page's content section&#10;              const contentSection = page&#10;                .getChildren()&#10;                .find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;              if (contentSection != null) contentSection.append(n);&#10;            }&#10;          });&#10;          root.append(page);&#10;        }&#10;&#10;        let page = root.getFirstChild();&#10;        let lastPageNode: PageNode | null = null;&#10;        let lastPageEl: HTMLElement | null = null;&#10;        let lastCapacity = 0;&#10;        let lastUsedScroll = 0;&#10;        while ($isPageNode(page)) {&#10;          const pageNode = page;&#10;          const pageEl = getPageEl(pageNode);&#10;          if (pageEl === null) {&#10;            page = pageNode.getNextSibling();&#10;            continue;&#10;          }&#10;          if (pageEl.clientHeight === 0 || pageEl.scrollHeight === 0) {&#10;            page = pageNode.getNextSibling();&#10;            continue;&#10;          }&#10;&#10;          const {&#10;            el: contentDomEl,&#10;            height: capacity,&#10;            top: contentTop,&#10;            paddingTop,&#10;            paddingBottom&#10;          } = getContentMetrics(pageEl);&#10;          // Resolve content section node&#10;          const contentSection = pageNode&#10;            .getChildren()&#10;            .find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;          const blocks = contentSection?.getChildren() ?? [];&#10;&#10;          // Deepest child bottom and sum of heights&#10;          let deepestBottom = contentTop;&#10;          let sumHeights = 0;&#10;          for (let i = 0; i &lt; blocks.length; i++) {&#10;            const el = editor.getElementByKey(blocks[i].getKey());&#10;            if (el == null) continue;&#10;            const r = el.getBoundingClientRect();&#10;            if (r.bottom &gt; deepestBottom) deepestBottom = r.bottom;&#10;            sumHeights += el.offsetHeight;&#10;          }&#10;          const usedDeepest = Math.max(0, deepestBottom - contentTop);&#10;          const usedSum = sumHeights;&#10;          const targetForScroll = contentDomEl ?? pageEl;&#10;          const usedScroll = getContentScrollHeight(targetForScroll, paddingTop, paddingBottom);&#10;&#10;          // Overflow if both metrics exceed, OR scroll-based says content exceeds capacity&#10;          const tolDeepest = 1;&#10;          const tolSum = 6;&#10;          const scrollTol = 2;&#10;          const overflow =&#10;            (usedDeepest &gt; capacity - tolDeepest &amp;&amp; usedSum &gt; capacity - tolSum) ||&#10;            usedScroll &gt; capacity + scrollTol;&#10;&#10;          if (overflow) {&#10;            const elementBlocks = blocks.filter(&#10;              (b): b is LexicalElementNode =&gt;&#10;                typeof (b as LexicalElementNode).getChildren === 'function'&#10;            );&#10;            const candidate = pickMovableBlock(elementBlocks);&#10;            if (candidate != null) {&#10;              if (blocks.length === 1) {&#10;                const el = editor.getElementByKey(candidate.getKey());&#10;                const currentH = el?.offsetHeight ?? usedDeepest;&#10;                const key = candidate.getKey();&#10;                if (!unbreakableTooTallKeysRef.current.has(key)) {&#10;                  const ok = proportionalSplitParagraphByHeight(candidate, currentH, capacity);&#10;                  if (!ok) {&#10;                    unbreakableTooTallKeysRef.current.add(key);&#10;                    let nextPage = pageNode.getNextSibling();&#10;                    if (!$isPageNode(nextPage)) {&#10;                      nextPage = $createPageNode();&#10;                      pageNode.insertAfter(nextPage);&#10;                    }&#10;                    const nextContent = nextPage&#10;                      .getChildren()&#10;                      .find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;                    if (nextContent != null) nextContent.append(candidate);&#10;                  }&#10;                }&#10;              } else {&#10;                let nextPage = pageNode.getNextSibling();&#10;                if (!$isPageNode(nextPage)) {&#10;                  nextPage = $createPageNode();&#10;                  pageNode.insertAfter(nextPage);&#10;                }&#10;                const nextContent = nextPage&#10;                  .getChildren()&#10;                  .find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;                if (nextContent != null) nextContent.append(candidate);&#10;              }&#10;&#10;              // Cursor otomatik yeni sayfaya taşınsın&#10;              const selection = $getSelection();&#10;              if ($isRangeSelection(selection)) {&#10;                const next = pageNode.getNextSibling();&#10;                if ($isPageNode(next)) {&#10;                  const nextContent = next&#10;                    .getChildren()&#10;                    .find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;                  const firstChild = nextContent?.getFirstChild() ?? null;&#10;                  if (firstChild != null) {&#10;                    firstChild.selectStart();&#10;                    // Cursor yeni sayfaya taşındıysa scroll et&#10;                    setTimeout(() =&gt; {&#10;                      const el = editor.getElementByKey(firstChild.getKey());&#10;                      if (el !== null) {&#10;                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });&#10;                      }&#10;                    }, 0);&#10;                  }&#10;                }&#10;              }&#10;&#10;              didMoveAny = true;&#10;            }&#10;          }&#10;&#10;          // Son sayfa ve doluysa yeni bir boş sayfa ekle&#10;          lastPageNode = pageNode;&#10;          lastPageEl = pageEl;&#10;          lastCapacity = capacity;&#10;          lastUsedScroll = usedScroll;&#10;&#10;          page = pageNode.getNextSibling();&#10;        }&#10;&#10;        // Son sayfa doluysa yeni bir boş sayfa ekle&#10;        if (&#10;          lastPageNode !== null &amp;&amp;&#10;          lastPageEl !== null &amp;&amp;&#10;          lastUsedScroll &gt; lastCapacity - 2 &amp;&amp;&#10;          lastPageNode.getNextSibling() === null&#10;        ) {&#10;          const newPage = $createPageNode();&#10;          // Header ve footer kopyala (sadece görünürse ekle)&#10;          const prevHeader = lastPageNode.getChildren().find((n) =&gt; isHeaderNode(n));&#10;          const prevFooter = lastPageNode.getChildren().find((n) =&gt; isFooterNode(n));&#10;          let headerNode = null;&#10;          let footerNode = null;&#10;          if (prevHeader !== null &amp;&amp; prevHeader !== undefined &amp;&amp; prevHeader.__visible !== false) {&#10;            headerNode = new PageHeaderNode(&#10;              prevHeader.__text ?? '',&#10;              undefined,&#10;              prevHeader.__visible ?? false&#10;            );&#10;            newPage.append(headerNode);&#10;          }&#10;          // Her zaman yeni bir content node ekle&#10;          const contentNode = new PageContentNode();&#10;          newPage.append(contentNode);&#10;          if (prevFooter !== null &amp;&amp; prevFooter !== undefined &amp;&amp; prevFooter.__visible !== false) {&#10;            footerNode = new PageFooterNode(&#10;              prevFooter.__text ?? '',&#10;              undefined,&#10;              prevFooter.__visible ?? false&#10;            );&#10;            newPage.append(footerNode);&#10;          }&#10;          lastPageNode.insertAfter(newPage);&#10;          // Cursor yeni content'e taşınsın ve scroll yapılsın&#10;          setTimeout(() =&gt; {&#10;            const el = editor.getElementByKey(newPage.getKey());&#10;            if (el !== null) {&#10;              el.scrollIntoView({ behavior: 'smooth', block: 'start' });&#10;            }&#10;            // Cursor yeni content'e&#10;            const contentEl = editor.getElementByKey(contentNode.getKey());&#10;            if (contentEl !== null) {&#10;              contentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });&#10;            }&#10;            editor.update(() =&gt; {&#10;              contentNode.selectStart();&#10;            });&#10;          }, 0);&#10;        }&#10;      });&#10;&#10;      return didMoveAny;&#10;    }&#10;&#10;    const schedule = (): void =&gt; {&#10;      if (isReflowingRef.current) return;&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      rafRef.current = requestAnimationFrame(() =&gt; {&#10;        isReflowingRef.current = true;&#10;        let passes = 0;&#10;        const maxPasses = 30;&#10;        const run = (): void =&gt; {&#10;          const moved = reflowPass();&#10;          passes++;&#10;          if (moved &amp;&amp; passes &lt; maxPasses) {&#10;            setTimeout(run, 0);&#10;          } else {&#10;            isReflowingRef.current = false;&#10;          }&#10;        };&#10;        setTimeout(run, 0);&#10;      });&#10;    };&#10;&#10;    schedule();&#10;&#10;    const unregister = editor.registerUpdateListener((): void =&gt; {&#10;      schedule();&#10;    });&#10;&#10;    return (): void =&gt; {&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      unregister();&#10;      isReflowingRef.current = false;&#10;    };&#10;  }, [editor, pageHeightMm, marginTopMm, marginBottomMm]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useEffect, useRef } from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import {&#10;  $getRoot,&#10;  $getSelection,&#10;  $isRangeSelection,&#10;  $isTextNode,&#10;  $createTextNode,&#10;  $createParagraphNode&#10;} from 'lexical';&#10;import type { ElementNode as LexicalElementNode } from 'lexical';&#10;import { $createPageNode, $isPageNode, type PageNode } from '../nodes/PageNode';&#10;import { isContentNode, isHeaderNode, isFooterNode } from '../nodes/sectionTypeGuards';&#10;import { PageHeaderNode } from '../nodes/PageHeaderNode';&#10;import { PageFooterNode } from '../nodes/PageFooterNode';&#10;import { PageContentNode } from '../nodes/PageContentNode';&#10;&#10;export interface PageFlowSettings {&#10;  pageHeightMm: number;&#10;  marginTopMm: number;&#10;  marginBottomMm: number;&#10;}&#10;&#10;export function PageAutoSplitPlugin({&#10;  pageHeightMm,&#10;  marginTopMm,&#10;  marginBottomMm&#10;}: PageFlowSettings): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const rafRef = useRef&lt;number | null&gt;(null);&#10;  const isReflowingRef = useRef(false);&#10;  const unbreakableTooTallKeysRef = useRef&lt;Set&lt;string&gt;&gt;(new Set());&#10;&#10;  useEffect(() =&gt; {&#10;    function getPageEl(page: PageNode): HTMLElement | null {&#10;      return editor.getElementByKey(page.getKey());&#10;    }&#10;&#10;    function getContentMetrics(pageEl: HTMLElement): {&#10;      el: HTMLElement | null;&#10;      top: number;&#10;      bottom: number;&#10;      height: number;&#10;      paddingTop: number;&#10;      paddingBottom: number;&#10;    } {&#10;      const el = pageEl.querySelector('[data-lexical-page-section=&quot;content&quot;]');&#10;      const contentEl = el instanceof HTMLElement ? el : null;&#10;      const target = contentEl ?? pageEl;&#10;      const rect = target.getBoundingClientRect();&#10;      const styles = window.getComputedStyle(target);&#10;      let paddingTop = parseFloat(styles.paddingTop);&#10;      let paddingBottom = parseFloat(styles.paddingBottom);&#10;      if (Number.isNaN(paddingTop)) paddingTop = 0;&#10;      if (Number.isNaN(paddingBottom)) paddingBottom = 0;&#10;      const top = rect.top + paddingTop;&#10;      const bottom = rect.bottom - paddingBottom;&#10;      return { el: contentEl, top, bottom, height: bottom - top, paddingTop, paddingBottom };&#10;    }&#10;&#10;    function getContentScrollHeight(&#10;      targetEl: HTMLElement,&#10;      paddingTop: number,&#10;      paddingBottom: number&#10;    ): number {&#10;      return targetEl.scrollHeight - paddingTop - paddingBottom;&#10;    }&#10;&#10;    function proportionalSplitParagraphByHeight(&#10;      block: LexicalElementNode,&#10;      currentHeightPx: number,&#10;      targetHeightPx: number&#10;    ): boolean {&#10;      const textNodes = block.getChildren().filter($isTextNode);&#10;      if (textNodes.length === 0) return false;&#10;      const totalChars = textNodes.reduce((sum, t) =&gt; sum + t.getTextContent().length, 0);&#10;      if (totalChars &lt; 2) return false;&#10;      const keepChars = Math.max(&#10;        1,&#10;        Math.min(totalChars - 1, Math.floor((targetHeightPx / currentHeightPx) * totalChars))&#10;      );&#10;      let remainingToKeep = keepChars;&#10;      const newPara = $createParagraphNode();&#10;      const movedNodes: Array&lt;ReturnType&lt;typeof $createTextNode&gt;&gt; = [];&#10;      for (const t of textNodes) {&#10;        if (remainingToKeep &lt;= 0) {&#10;          movedNodes.push($createTextNode(t.getTextContent()));&#10;          t.remove();&#10;          continue;&#10;        }&#10;        const text = t.getTextContent();&#10;        if (text.length &lt;= remainingToKeep) {&#10;          remainingToKeep -= text.length;&#10;          continue;&#10;        }&#10;        const left = text.slice(0, remainingToKeep);&#10;        const right = text.slice(remainingToKeep);&#10;        t.setTextContent(left);&#10;        movedNodes.push($createTextNode(right));&#10;        remainingToKeep = 0;&#10;      }&#10;      if (movedNodes.length === 0) return false;&#10;      movedNodes.forEach((n) =&gt; newPara.append(n));&#10;      block.insertAfter(newPara);&#10;      return true;&#10;    }&#10;&#10;    function pickMovableBlock(blocks: LexicalElementNode[]): LexicalElementNode | null {&#10;      for (let i = blocks.length - 1; i &gt;= 0; i--) {&#10;        const node = blocks[i];&#10;        const el = editor.getElementByKey(node.getKey());&#10;        const height = el?.offsetHeight ?? 0;&#10;        const textGetter = (node as unknown as { getTextContent?: () =&gt; string }).getTextContent;&#10;        const text = typeof textGetter === 'function' ? textGetter.call(node) : '';&#10;        if ((text?.trim()?.length ?? 0) &gt; 0 || height &gt; 2) {&#10;          return node;&#10;        }&#10;      }&#10;      return blocks.length &gt; 0 ? blocks[blocks.length - 1] : null;&#10;    }&#10;&#10;    function moveOverflowBlocksToNextPage(pageNode: PageNode, capacity: number, usedScroll: number) {&#10;      const contentSection = pageNode.getChildren().find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;      if (!contentSection) return;&#10;      const blocks = contentSection.getChildren();&#10;      if (blocks.length === 0) return;&#10;      const el = editor.getElementByKey(contentSection.getKey());&#10;      if (!el) return;&#10;      if (el.scrollHeight &lt;= capacity + 2) return;&#10;      // Fazla bloğu bul ve taşı&#10;      let nextPage = pageNode.getNextSibling();&#10;      if (!$isPageNode(nextPage)) {&#10;        nextPage = $createPageNode();&#10;        // Header/footer kopyala&#10;        const prevHeader = pageNode.getChildren().find((n) =&gt; isHeaderNode(n));&#10;        const prevFooter = pageNode.getChildren().find((n) =&gt; isFooterNode(n));&#10;        if (prevHeader &amp;&amp; prevHeader.__visible !== false) {&#10;          nextPage.append(new PageHeaderNode(prevHeader.__text ?? '', undefined, prevHeader.__visible ?? false));&#10;        }&#10;        nextPage.append(new PageContentNode());&#10;        if (prevFooter &amp;&amp; prevFooter.__visible !== false) {&#10;          nextPage.append(new PageFooterNode(prevFooter.__text ?? '', undefined, prevFooter.__visible ?? false));&#10;        }&#10;        pageNode.insertAfter(nextPage);&#10;      }&#10;      const nextContent = nextPage.getChildren().find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;      if (!nextContent) return;&#10;      // Son bloğu taşı&#10;      const lastBlock = blocks[blocks.length - 1];&#10;      nextContent.append(lastBlock);&#10;    }&#10;&#10;    function reflowPass(): boolean {&#10;      let didMoveAny = false;&#10;      editor.update(() =&gt; {&#10;        const root = $getRoot();&#10;        if (root.getChildrenSize() === 0) {&#10;          root.append($createPageNode());&#10;          return;&#10;        }&#10;        const children = root.getChildren();&#10;        const hasNonPage = children.some((n) =&gt; !$isPageNode(n));&#10;        if (hasNonPage) {&#10;          const page = $createPageNode();&#10;          children.forEach((n) =&gt; {&#10;            if (!$isPageNode(n)) {&#10;              const contentSection = page.getChildren().find((c: any): c is PageContentNode =&gt; isContentNode(c));&#10;              if (contentSection != null) contentSection.append(n);&#10;            }&#10;          });&#10;          root.append(page);&#10;        }&#10;        // Tüm sayfalar için flow kontrolü&#10;        let page = root.getFirstChild();&#10;        while ($isPageNode(page)) {&#10;          const pageNode = page;&#10;          const pageEl = getPageEl(pageNode);&#10;          if (pageEl === null) {&#10;            page = pageNode.getNextSibling();&#10;            continue;&#10;          }&#10;          const { el: contentDomEl, height: capacity, paddingTop, paddingBottom } = getContentMetrics(pageEl);&#10;          const targetForScroll = contentDomEl ?? pageEl;&#10;          const usedScroll = getContentScrollHeight(targetForScroll, paddingTop, paddingBottom);&#10;          if (usedScroll &gt; capacity + 2) {&#10;            moveOverflowBlocksToNextPage(pageNode, capacity, usedScroll);&#10;            didMoveAny = true;&#10;          }&#10;          page = pageNode.getNextSibling();&#10;        }&#10;      });&#10;      return didMoveAny;&#10;    }&#10;&#10;    const schedule = (): void =&gt; {&#10;      if (isReflowingRef.current) return;&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      rafRef.current = requestAnimationFrame(() =&gt; {&#10;        isReflowingRef.current = true;&#10;        let passes = 0;&#10;        const maxPasses = 30;&#10;        const run = (): void =&gt; {&#10;          const moved = reflowPass();&#10;          passes++;&#10;          if (moved &amp;&amp; passes &lt; maxPasses) {&#10;            setTimeout(run, 0);&#10;          } else {&#10;            isReflowingRef.current = false;&#10;          }&#10;        };&#10;        setTimeout(run, 0);&#10;      });&#10;    };&#10;&#10;    schedule();&#10;&#10;    const unregister = editor.registerUpdateListener((): void =&gt; {&#10;      schedule();&#10;    });&#10;&#10;    return (): void =&gt; {&#10;      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);&#10;      unregister();&#10;      isReflowingRef.current = false;&#10;    };&#10;  }, [editor, pageHeightMm, marginTopMm, marginBottomMm]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/PageContentFlowPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/PageContentFlowPlugin.tsx" />
              <option name="originalContent" value="import { useEffect } from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import {&#10;  $getRoot,&#10;  $isElementNode,&#10;  $isTextNode&#10;} from 'lexical';&#10;import { $isPageNode } from '../nodes/PageNode';&#10;import { isContentNode } from '../nodes/sectionTypeGuards';&#10;&#10;/**&#10; * PageContentFlowPlugin&#10; *&#10; * Eğer bir sayfa taşarsa (overflow), fazla içeriği otomatik olarak yeni sayfaya aktarır.&#10; * Bu plugin, PageAutoSplitPlugin ile birlikte çalışacak şekilde tasarlanmıştır.&#10; */&#10;const PageContentFlowPlugin: React.FC = () =&gt; {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    // Her güncellemede çalışacak şekilde listener ekle&#10;    const unregister = editor.registerUpdateListener(() =&gt; {&#10;      editor.update(() =&gt; {&#10;        const root = $getRoot();&#10;        const pages = root.getChildren().filter($isPageNode);&#10;        for (let i = 0; i &lt; pages.length - 1; i++) {&#10;          const page = pages[i];&#10;          const nextPage = pages[i + 1];&#10;          const contentNode = page.getChildren().find(isContentNode);&#10;          const nextContentNode = nextPage.getChildren().find(isContentNode);&#10;          if (contentNode == null || nextContentNode == null) { continue; }&#10;&#10;          const el = editor.getElementByKey(contentNode.getKey());&#10;          if (el == null) { continue; }&#10;          const maxHeight = 1122 - 40; // örnek: 20px üst/alt margin&#10;          // Sadece taşma varsa müdahale et&#10;          if (el.scrollHeight &gt; maxHeight + 2) {&#10;            const blocks = contentNode.getChildren();&#10;            if (blocks.length &gt; 1) {&#10;              // Sadece son bloğu taşı (veya ilk bloğu, tercihe göre)&#10;              const lastBlock = blocks[blocks.length - 1];&#10;              nextContentNode.append(lastBlock);&#10;              break; // Bir seferde sadece bir blok taşı, döngüyü kır&#10;            } else if (blocks.length === 1) {&#10;              // Tek blok varsa ve çok uzunsa, metni böl&#10;              const block = blocks[0];&#10;              if ($isElementNode(block)) {&#10;                const textNodes = block.getChildren().filter($isTextNode);&#10;                if (textNodes.length &gt; 0) {&#10;                  const t = textNodes[0];&#10;                  const text = t.getTextContent();&#10;                  if (text.length &gt; 10) {&#10;                    // Sadece taşan kısmı böl: örn. 1/3'ünü yeni sayfaya aktar&#10;                    const splitAt = Math.floor(text.length * 2 / 3);&#10;                    t.setTextContent(text.slice(0, splitAt));&#10;                    const newBlock = block.clone();&#10;                    newBlock.getChildren().forEach((c: any) =&gt; c.remove());&#10;                    const newTextNode = t.clone();&#10;                    newTextNode.setTextContent(text.slice(splitAt));&#10;                    newBlock.append(newTextNode);&#10;                    nextContentNode.append(newBlock);&#10;                    break; // Bir seferde sadece bir blok taşı, döngüyü kır&#10;                  }&#10;                }&#10;              }&#10;            }&#10;          }&#10;        }&#10;      });&#10;    });&#10;    return unregister;&#10;  }, [editor]);&#10;&#10;  return null;&#10;};&#10;&#10;export default PageContentFlowPlugin;&#10;" />
              <option name="updatedContent" value="import { useEffect } from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import {&#10;  $getRoot,&#10;  $isElementNode,&#10;  $isTextNode&#10;} from 'lexical';&#10;import { $isPageNode } from '../nodes/PageNode';&#10;import { isContentNode } from '../nodes/sectionTypeGuards';&#10;&#10;/**&#10; * PageContentFlowPlugin&#10; *&#10; * Eğer bir sayfa taşarsa (overflow), fazla içeriği otomatik olarak yeni sayfaya aktarır.&#10; * Bu plugin, PageAutoSplitPlugin ile birlikte çalışacak şekilde tasarlanmıştır.&#10; */&#10;// PageContentFlowPlugin'i devre dışı bırakıyoruz. Artık içerik taşımayı ve yeni sayfa eklemeyi sadece PageAutoSplitPlugin yönetecek.&#10;const PageContentFlowPlugin: React.FC = () =&gt; {&#10;  return null;&#10;};&#10;&#10;export default PageContentFlowPlugin;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/editor/plugins/SectionToolbarPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/editor/plugins/SectionToolbarPlugin.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { PageNode } from '../nodes/PageNode';&#10;&#10;interface Props {&#10;  editMode: boolean;&#10;  setEditMode: (v: boolean) =&gt; void;&#10;  showHeader: boolean;&#10;  setShowHeader: (v: boolean) =&gt; void;&#10;  showFooter: boolean;&#10;  setShowFooter: (v: boolean) =&gt; void;&#10;}&#10;&#10;export function SectionToolbarPlugin({&#10;  editMode,&#10;  setEditMode,&#10;  showHeader,&#10;  setShowHeader,&#10;  showFooter,&#10;  setShowFooter,&#10;}: Props) {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  const handleAddSection = () =&gt; {&#10;    PageNode.createSection(editor);&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setEditMode(!editMode)}&#10;        className={editMode ? 'active' : ''}&#10;        style={{ marginLeft: 16 }}&#10;        title={editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;      &gt;&#10;        {editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;      &lt;/button&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setShowHeader(!showHeader)}&#10;        className={showHeader ? 'active' : ''}&#10;        style={{ marginLeft: 8 }}&#10;        title={showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;      &gt;&#10;        {showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;      &lt;/button&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setShowFooter(!showFooter)}&#10;        className={showFooter ? 'active' : ''}&#10;        style={{ marginLeft: 8 }}&#10;        title={showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;      &gt;&#10;        {showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;      &lt;/button&gt;&#10;      &lt;button&#10;        onClick={handleAddSection}&#10;        style={{ marginLeft: 8 }}&#10;        title=&quot;Section Ekle&quot;&#10;      &gt;&#10;        Section Ekle&#10;      &lt;/button&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { PageNode } from '../nodes/PageNode';&#10;import * as Toolbar from '@radix-ui/react-toolbar';&#10;&#10;interface Props {&#10;  editMode: boolean;&#10;  setEditMode: (v: boolean) =&gt; void;&#10;  showHeader: boolean;&#10;  setShowHeader: (v: boolean) =&gt; void;&#10;  showFooter: boolean;&#10;  setShowFooter: (v: boolean) =&gt; void;&#10;}&#10;&#10;export function SectionToolbarPlugin({&#10;  editMode,&#10;  setEditMode,&#10;  showHeader,&#10;  setShowHeader,&#10;  showFooter,&#10;  setShowFooter,&#10;}: Props) {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  const handleAddSection = () =&gt; {&#10;    PageNode.createSection(editor);&#10;  };&#10;&#10;  return (&#10;    &lt;Toolbar.Root className=&quot;toolbarRoot&quot;&gt;&#10;      &lt;div className=&quot;toolbarGroup&quot;&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={() =&gt; setEditMode(!editMode)}&#10;          className={`toolbarButton${editMode ? ' active' : ''}`}&#10;          title={editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;        &gt;&#10;          {editMode ? 'Düzenleme Modunu Kapat' : 'Header/Footer Düzenle'}&#10;        &lt;/Toolbar.Button&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={() =&gt; setShowHeader(!showHeader)}&#10;          className={`toolbarButton${showHeader ? ' active' : ''}`}&#10;          title={showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;        &gt;&#10;          {showHeader ? 'Header Kaldır' : 'Header Ekle'}&#10;        &lt;/Toolbar.Button&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={() =&gt; setShowFooter(!showFooter)}&#10;          className={`toolbarButton${showFooter ? ' active' : ''}`}&#10;          title={showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;        &gt;&#10;          {showFooter ? 'Footer Kaldır' : 'Footer Ekle'}&#10;        &lt;/Toolbar.Button&gt;&#10;        &lt;Toolbar.Button&#10;          onClick={handleAddSection}&#10;          className=&quot;toolbarButton&quot;&#10;          title=&quot;Section Ekle&quot;&#10;        &gt;&#10;          Section Ekle&#10;        &lt;/Toolbar.Button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Toolbar.Root&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import {&#10;  DEFAULT_PAGINATION_SETTINGS,&#10;  type PaginationSettings&#10;} from './plugins/pagination/PaginationSettings';&#10;import { PageBreakNode } from './plugins/pagination/PageBreakNode';&#10;import { WordCountPlugin } from './plugins/WordCountPlugin';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import './styles.css';&#10;import { BannerNode, BannerPlugin } from './plugins/banner/BannerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;export default function Editor({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): JSX.Element {&#10;  const [pageCount, setPageCount] = React.useState(1);&#10;  const paginationSettings: PaginationSettings = DEFAULT_PAGINATION_SETTINGS;&#10;&#10;  const handlePageCountChange = React.useCallback((count: number) =&gt; {&#10;    setPageCount(count);&#10;  }, []);&#10;&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [PageBreakNode, BannerNode]&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-container paginated&quot;&gt;&#10;      &lt;div className=&quot;page-indicator&quot;&gt;Page {pageCount}&lt;/div&gt;&#10;      &lt;div&#10;        className=&quot;a4-page&quot;&#10;        style={{&#10;          width: `${paginationSettings.pageWidth}mm`,&#10;          minHeight: `${paginationSettings.pageHeight}mm`,&#10;          margin: `${paginationSettings.marginTop}mm ${paginationSettings.marginRight}mm ${paginationSettings.marginBottom}mm ${paginationSettings.marginLeft}mm`&#10;        }}&#10;      &gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;ToolbarPlugin /&gt;&#10;          &lt;BannerPlugin /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;            placeholder={&lt;div className=&quot;placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;PaginationPlugin&#10;            settings={paginationSettings}&#10;            onPageCountChange={handlePageCountChange}&#10;          /&gt;&#10;          &lt;WordCountPlugin onWordCountChange={onWordCountChange} /&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { PaginationPlugin } from './plugins/pagination/PaginationPlugin';&#10;import { DEFAULT_PAGINATION_SETTINGS, type PaginationSettings } from './plugins/pagination/PaginationSettings';&#10;import { PageBreakNode } from './plugins/pagination/PageBreakNode';&#10;import { WordCountPlugin } from './plugins/WordCountPlugin';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import './styles.css';&#10;import { BannerNode, BannerPlugin } from './plugins/banner/BannerPlugin';&#10;&#10;const theme = {&#10;  text: {&#10;    bold: 'editor-bold',&#10;    italic: 'editor-italic',&#10;    underline: 'editor-underline'&#10;  }&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;export default function Editor({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): JSX.Element {&#10;  const [pageCount, setPageCount] = React.useState(1);&#10;  const paginationSettings: PaginationSettings = DEFAULT_PAGINATION_SETTINGS;&#10;&#10;  const handlePageCountChange = React.useCallback((count: number) =&gt; {&#10;    setPageCount(count);&#10;  }, []);&#10;&#10;  const initialConfig = {&#10;    namespace: 'SimpleEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [PageBreakNode, BannerNode]&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-container paginated&quot;&gt;&#10;      &lt;div className=&quot;page-indicator&quot;&gt;Page {pageCount}&lt;/div&gt;&#10;      &lt;div&#10;        className=&quot;a4-page&quot;&#10;        style={{&#10;          width: `${paginationSettings.pageWidth}mm`,&#10;          minHeight: `${paginationSettings.pageHeight}mm`,&#10;          margin: `${paginationSettings.marginTop}mm ${paginationSettings.marginRight}mm ${paginationSettings.marginBottom}mm ${paginationSettings.marginLeft}mm`&#10;        }}&#10;      &gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;ToolbarPlugin /&gt;&#10;          &lt;BannerPlugin /&gt;&#10;          &lt;RichTextPlugin&#10;            contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;            placeholder={&lt;div className=&quot;placeholder&quot;&gt;Start typing...&lt;/div&gt;}&#10;            ErrorBoundary={LexicalErrorBoundary}&#10;          /&gt;&#10;          &lt;HistoryPlugin /&gt;&#10;          &lt;PaginationPlugin&#10;            settings={paginationSettings}&#10;            onPageCountChange={handlePageCountChange}&#10;          /&gt;&#10;          &lt;WordCountPlugin onWordCountChange={onWordCountChange} /&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/WordCountPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/WordCountPlugin.tsx" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { useEffect } from 'react';&#10;import { $getRoot } from 'lexical';&#10;&#10;export function WordCountPlugin({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange?: (words: number, chars: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(() =&gt; {&#10;      editor.getEditorState().read(() =&gt; {&#10;        const text = $getRoot().getTextContent();&#10;        const words = text.trim().split(/\s+/).filter((word) =&gt; word.length &gt; 0).length;&#10;        const chars = text.length;&#10;        onWordCountChange?.(words, chars);&#10;      });&#10;    });&#10;  }, [editor, onWordCountChange]);&#10;&#10;  return null;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, type PageBreakNode } from './PageBreakNode';&#10;&#10;export interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;export const DEFAULT_PAGINATION_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210, // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20&#10;};&#10;&#10;export const PAGINATION_PRESETS: Record&lt;string, Partial&lt;PaginationSettings&gt;&gt; = {&#10;  A4: { pageWidth: 210, pageHeight: 297 },&#10;  A3: { pageWidth: 297, pageHeight: 420 },&#10;  Letter: { pageWidth: 216, pageHeight: 279 },&#10;  Legal: { pageWidth: 216, pageHeight: 356 }&#10;};&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_PAGINATION_SETTINGS,&#10;  onPageCountChange&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const finalSettings = { ...DEFAULT_PAGINATION_SETTINGS, ...settings };&#10;  const contentHeight =&#10;    finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: Array&lt;{ index: number; pageNumber: number }&gt; = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Collect existing page breaks&#10;      children.forEach((child) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach((pageBreak) =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element !== null) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const nodeAtIndex = root.getChildAtIndex(index);&#10;        if (nodeAtIndex !== null) {&#10;          const pageBreak = $createPageBreakNode(pageNumber);&#10;          nodeAtIndex.insertBefore(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      onPageCountChange?.(newPageCount);&#10;    });&#10;  }, [editor, contentHeight, onPageCountChange]);&#10;&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; {&#10;      clearTimeout(timer);&#10;    };&#10;  }, [checkForPageBreak]);&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ dirtyElements, dirtyLeaves }) =&gt; {&#10;      if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;        setTimeout(() =&gt; {&#10;          checkForPageBreak();&#10;        }, 100);&#10;      }&#10;    });&#10;  }, [editor, checkForPageBreak]);&#10;&#10;  return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;import { useEffect, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, type PageBreakNode } from './PageBreakNode';&#10;import { PaginationSettings, DEFAULT_PAGINATION_SETTINGS, PAGINATION_PRESETS } from './PaginationSettings';&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_PAGINATION_SETTINGS,&#10;  onPageCountChange&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const finalSettings = { ...DEFAULT_PAGINATION_SETTINGS, ...settings };&#10;  const contentHeight =&#10;    finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: Array&lt;{ index: number; pageNumber: number }&gt; = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Collect existing page breaks&#10;      children.forEach((child) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach((pageBreak) =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element !== null) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const nodeAtIndex = root.getChildAtIndex(index);&#10;        if (nodeAtIndex !== null) {&#10;          const pageBreak = $createPageBreakNode(pageNumber);&#10;          nodeAtIndex.insertBefore(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      onPageCountChange?.(newPageCount);&#10;    });&#10;  }, [editor, contentHeight, onPageCountChange]);&#10;&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; {&#10;      clearTimeout(timer);&#10;    };&#10;  }, [checkForPageBreak]);&#10;&#10;  useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ dirtyElements, dirtyLeaves }) =&gt; {&#10;      if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;        setTimeout(() =&gt; {&#10;          checkForPageBreak();&#10;        }, 100);&#10;      }&#10;    });&#10;  }, [editor, checkForPageBreak]);&#10;&#10;  return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettingsPanel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettingsPanel.tsx" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import type { PaginationSettings } from './PaginationPlugin';&#10;&#10;interface PaginationSettingsProps {&#10;  settings: PaginationSettings;&#10;  onSettingsChange: (settings: PaginationSettings) =&gt; void;&#10;  isVisible: boolean;&#10;  onToggle: () =&gt; void;&#10;}&#10;&#10;export function PaginationSettingsPanel({&#10;  settings,&#10;  onSettingsChange,&#10;  isVisible,&#10;  onToggle&#10;}: PaginationSettingsProps): JSX.Element {&#10;  const [localSettings, setLocalSettings] = useState(settings);&#10;&#10;  const handleChange = (field: keyof PaginationSettings, value: number): void =&gt; {&#10;    const newSettings = { ...localSettings, [field]: value };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  const presets = {&#10;    A4: { pageWidth: 210, pageHeight: 297 },&#10;    A3: { pageWidth: 297, pageHeight: 420 },&#10;    Letter: { pageWidth: 216, pageHeight: 279 },&#10;    Legal: { pageWidth: 216, pageHeight: 356 }&#10;  };&#10;&#10;  const applyPreset = (preset: keyof typeof presets): void =&gt; {&#10;    const newSettings = {&#10;      ...localSettings,&#10;      ...presets[preset]&#10;    };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  if (!isVisible) {&#10;    return (&#10;      &lt;button className=&quot;pagination-control-btn settings-toggle&quot; onClick={onToggle}&gt;&#10;        ⚙️&#10;      &lt;/button&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;page-settings&quot;&gt;&#10;      &lt;div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}&gt;&#10;        &lt;h3&gt;Sayfa Ayarları&lt;/h3&gt;&#10;        &lt;button&#10;          onClick={onToggle}&#10;          style={{&#10;            background: 'none',&#10;            border: 'none',&#10;            cursor: 'pointer',&#10;            fontSize: '16px'&#10;          }}&#10;        &gt;&#10;          ✕&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div style={{ marginBottom: '12px' }}&gt;&#10;        &lt;label&gt;Sayfa Boyutu Önayarları:&lt;/label&gt;&#10;        &lt;div style={{ display: 'flex', gap: '4px', marginTop: '4px' }}&gt;&#10;          {Object.keys(presets).map((preset) =&gt; (&#10;            &lt;button&#10;              key={preset}&#10;              onClick={() =&gt; {&#10;                applyPreset(preset as keyof typeof presets);&#10;              }}&#10;              style={{&#10;                padding: '4px 8px',&#10;                border: '1px solid #d1d1d1',&#10;                borderRadius: '2px',&#10;                background: 'white',&#10;                cursor: 'pointer',&#10;                fontSize: '10px'&#10;              }}&#10;            &gt;&#10;              {preset}&#10;            &lt;/button&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;label&gt;&#10;        Genişlik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageWidth}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageWidth', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;500&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Yükseklik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageHeight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageHeight', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;700&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Üst Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginTop}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginTop', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Alt Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginBottom}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginBottom', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sol Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginLeft}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginLeft', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sağ Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginRight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginRight', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;div style={{ marginTop: '12px', fontSize: '10px', color: '#666' }}&gt;&#10;        Ctrl+Enter: Yeni sayfa ekle&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="export interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;export const DEFAULT_PAGINATION_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210,  // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20&#10;};&#10;&#10;export const PAGINATION_PRESETS: Record&lt;string, Partial&lt;PaginationSettings&gt;&gt; = {&#10;  A4: { pageWidth: 210, pageHeight: 297 },&#10;  A3: { pageWidth: 297, pageHeight: 420 },&#10;  Letter: { pageWidth: 216, pageHeight: 279 },&#10;  Legal: { pageWidth: 216, pageHeight: 356 }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>