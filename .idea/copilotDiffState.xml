<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/Editor.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import './styles.css';&#10;import './plugins/pagination/styles.css';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { HeadingNode } from '@lexical/rich-text';&#10;import { ListPlugin } from '@lexical/react/LexicalListPlugin';&#10;import { ListNode, ListItemNode } from '@lexical/list';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import { BannerPlugin, BannerNode } from './plugins/banner/BannerPlugin';&#10;import { PaginationPlugin, PaginationSettings, defaultPaginationSettings } from './plugins/pagination/PaginationPlugin';&#10;import { PageBreakNode } from './plugins/pagination/PaginationNode';&#10;import { PaginationSettingsPanel } from './plugins/pagination/PaginationSettings';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;&#10;const theme = {&#10;  heading: {&#10;    h1: 'glyf-editor-h1',&#10;    h2: 'glyf-editor-h2',&#10;    h3: 'glyf-editor-h3'&#10;  },&#10;  text: {&#10;    bold: 'glyf-editor-bold',&#10;    italic: 'glyf-editor-italic',&#10;    underline: 'glyf-editor-underline',&#10;    strikethrough: 'glyf-editor-strikethrough',&#10;    underlineStrikethrough: 'glyf-editor-underlineStrikethrough'&#10;  },&#10;  banner: 'glyf-editor-banner'&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;// Kelime ve karakter sayacı bileşeni&#10;function WordCountPlugin({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange: (wordCount: number, charCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  React.useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ editorState }) =&gt; {&#10;      editorState.read(() =&gt; {&#10;        const root = $getRoot();&#10;        const textContent = root.getTextContent();&#10;        const wordCount = textContent.trim() === '' ? 0 : textContent.trim().split(/\s+/).length;&#10;        const charCount = textContent.length;&#10;        onWordCountChange(wordCount, charCount);&#10;      });&#10;    });&#10;  }, [editor, onWordCountChange]);&#10;&#10;  return null;&#10;}&#10;&#10;interface EditorProps {&#10;  onWordCountChange?: (wordCount: number, charCount: number) =&gt; void;&#10;}&#10;&#10;export default function Editor({ onWordCountChange }: EditorProps): JSX.Element {&#10;  const handleWordCountChange = React.useCallback(&#10;    (words: number, chars: number) =&gt; {&#10;      onWordCountChange?.(words, chars);&#10;    },&#10;    [onWordCountChange]&#10;  );&#10;&#10;  const initialConfig = {&#10;    namespace: 'GlyfEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [HeadingNode, ListNode, ListItemNode, BannerNode, PageBreakNode]&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;editor-container&quot;&gt;&#10;      &lt;div className=&quot;a4-page&quot;&gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;div className=&quot;toolbar-wrapper&quot;&gt;&#10;            &lt;ToolbarPlugin /&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div className=&quot;a4-content&quot;&gt;&#10;            &lt;RichTextPlugin&#10;              contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;              placeholder={&lt;div className=&quot;placeholder&quot;&gt;Yazmaya başlayın...&lt;/div&gt;}&#10;              ErrorBoundary={LexicalErrorBoundary}&#10;            /&gt;&#10;            &lt;BannerPlugin /&gt;&#10;            &lt;ListPlugin /&gt;&#10;            &lt;HistoryPlugin /&gt;&#10;            &lt;WordCountPlugin onWordCountChange={handleWordCountChange} /&gt;&#10;            &lt;PaginationPlugin /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import './styles.css';&#10;import './plugins/pagination/styles.css';&#10;import { LexicalComposer } from '@lexical/react/LexicalComposer';&#10;import { ContentEditable } from '@lexical/react/LexicalContentEditable';&#10;import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';&#10;import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';&#10;import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';&#10;import { HeadingNode } from '@lexical/rich-text';&#10;import { ListPlugin } from '@lexical/react/LexicalListPlugin';&#10;import { ListNode, ListItemNode } from '@lexical/list';&#10;import { ToolbarPlugin } from '../glyf-toolbar/Toolbar';&#10;import { BannerPlugin, BannerNode } from './plugins/banner/BannerPlugin';&#10;import { PaginationPlugin, PaginationSettings, defaultPaginationSettings } from './plugins/pagination/PaginationPlugin';&#10;import { PageBreakNode } from './plugins/pagination/PaginationNode';&#10;import { PaginationSettingsPanel } from './plugins/pagination/PaginationSettings';&#10;import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import { $getRoot } from 'lexical';&#10;&#10;const theme = {&#10;  heading: {&#10;    h1: 'glyf-editor-h1',&#10;    h2: 'glyf-editor-h2',&#10;    h3: 'glyf-editor-h3'&#10;  },&#10;  text: {&#10;    bold: 'glyf-editor-bold',&#10;    italic: 'glyf-editor-italic',&#10;    underline: 'glyf-editor-underline',&#10;    strikethrough: 'glyf-editor-strikethrough',&#10;    underlineStrikethrough: 'glyf-editor-underlineStrikethrough'&#10;  },&#10;  banner: 'glyf-editor-banner'&#10;};&#10;&#10;function onError(error: Error): void {&#10;  console.error(error);&#10;}&#10;&#10;// Kelime ve karakter sayacı bileşeni&#10;function WordCountPlugin({&#10;  onWordCountChange&#10;}: {&#10;  onWordCountChange: (wordCount: number, charCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;&#10;  React.useEffect(() =&gt; {&#10;    return editor.registerUpdateListener(({ editorState }) =&gt; {&#10;      editorState.read(() =&gt; {&#10;        const root = $getRoot();&#10;        const textContent = root.getTextContent();&#10;        const wordCount = textContent.trim() === '' ? 0 : textContent.trim().split(/\s+/).length;&#10;        const charCount = textContent.length;&#10;        onWordCountChange(wordCount, charCount);&#10;      });&#10;    });&#10;  }, [editor, onWordCountChange]);&#10;&#10;  return null;&#10;}&#10;&#10;interface EditorProps {&#10;  onWordCountChange?: (wordCount: number, charCount: number) =&gt; void;&#10;  enablePagination?: boolean;&#10;}&#10;&#10;export default function Editor({ onWordCountChange, enablePagination = true }: EditorProps): JSX.Element {&#10;  const [pageCount, setPageCount] = React.useState(1);&#10;  const [paginationSettings, setPaginationSettings] = React.useState&lt;PaginationSettings&gt;(defaultPaginationSettings);&#10;  const [showSettings, setShowSettings] = React.useState(false);&#10;&#10;  const handleWordCountChange = React.useCallback(&#10;    (words: number, chars: number) =&gt; {&#10;      onWordCountChange?.(words, chars);&#10;    },&#10;    [onWordCountChange]&#10;  );&#10;&#10;  const handlePageCountChange = React.useCallback((count: number) =&gt; {&#10;    setPageCount(count);&#10;  }, []);&#10;&#10;  const handleSettingsChange = React.useCallback((settings: PaginationSettings) =&gt; {&#10;    setPaginationSettings(settings);&#10;  }, []);&#10;&#10;  const initialConfig = {&#10;    namespace: 'GlyfEditor',&#10;    theme,&#10;    onError,&#10;    nodes: [HeadingNode, ListNode, ListItemNode, BannerNode, ...(enablePagination ? [PageBreakNode] : [])]&#10;  };&#10;&#10;  return (&#10;    &lt;div className={`editor-container ${enablePagination ? 'paginated' : ''}`}&gt;&#10;      {enablePagination &amp;&amp; (&#10;        &lt;&gt;&#10;          &lt;PaginationSettingsPanel&#10;            settings={paginationSettings}&#10;            onSettingsChange={handleSettingsChange}&#10;            isVisible={showSettings}&#10;            onToggle={() =&gt; setShowSettings(!showSettings)}&#10;          /&gt;&#10;          &#10;          &lt;div className=&quot;page-indicator&quot;&gt;&#10;            Sayfa {pageCount} / {pageCount}&#10;          &lt;/div&gt;&#10;        &lt;/&gt;&#10;      )}&#10;      &#10;      &lt;div className=&quot;a4-page&quot; style={enablePagination ? {&#10;        width: `${paginationSettings.pageWidth}mm`,&#10;        minHeight: `${paginationSettings.pageHeight}mm`,&#10;      } : {}}&gt;&#10;        &lt;LexicalComposer initialConfig={initialConfig}&gt;&#10;          &lt;div className=&quot;toolbar-wrapper&quot;&gt;&#10;            &lt;ToolbarPlugin /&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div className=&quot;a4-content&quot;&gt;&#10;            &lt;RichTextPlugin&#10;              contentEditable={&lt;ContentEditable className=&quot;contentEditable&quot; /&gt;}&#10;              placeholder={&lt;div className=&quot;placeholder&quot;&gt;Yazmaya başlayın...&lt;/div&gt;}&#10;              ErrorBoundary={LexicalErrorBoundary}&#10;            /&gt;&#10;            &lt;BannerPlugin /&gt;&#10;            &lt;ListPlugin /&gt;&#10;            &lt;HistoryPlugin /&gt;&#10;            &lt;WordCountPlugin onWordCountChange={handleWordCountChange} /&gt;&#10;            {enablePagination &amp;&amp; (&#10;              &lt;PaginationPlugin &#10;                settings={paginationSettings}&#10;                onPageCountChange={handlePageCountChange}&#10;              /&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/LexicalComposer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationNode.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationNode.tsx" />
              <option name="originalContent" value="import {&#10;  $applyNodeReplacement,&#10;  $createParagraphNode,&#10;  $getSelection,&#10;  $isRangeSelection,&#10;  DOMConversionMap,&#10;  DOMConversionOutput,&#10;  DOMExportOutput,&#10;  EditorConfig,&#10;  LexicalNode,&#10;  NodeKey,&#10;  SerializedElementNode,&#10;  Spread,&#10;} from 'lexical';&#10;import { ElementNode } from 'lexical';&#10;&#10;export type SerializedPageBreakNode = Spread&lt;&#10;  {&#10;    pageNumber: number;&#10;  },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;export class PageBreakNode extends ElementNode {&#10;  __pageNumber: number;&#10;&#10;  static getType(): string {&#10;    return 'page-break';&#10;  }&#10;&#10;  static clone(node: PageBreakNode): PageBreakNode {&#10;    return new PageBreakNode(node.__pageNumber, node.__key);&#10;  }&#10;&#10;  constructor(pageNumber: number, key?: NodeKey) {&#10;    super(key);&#10;    this.__pageNumber = pageNumber;&#10;  }&#10;&#10;  getPageNumber(): number {&#10;    return this.__pageNumber;&#10;  }&#10;&#10;  setPageNumber(pageNumber: number): void {&#10;    const writable = this.getWritable();&#10;    writable.__pageNumber = pageNumber;&#10;  }&#10;&#10;  createDOM(config: EditorConfig): HTMLElement {&#10;    const element = document.createElement('div');&#10;    element.setAttribute('data-lexical-page-break', 'true');&#10;    element.setAttribute('data-page-number', this.__pageNumber.toString());&#10;    element.className = 'page-break';&#10;    return element;&#10;  }&#10;&#10;  updateDOM(): false {&#10;    return false;&#10;  }&#10;&#10;  static importDOM(): DOMConversionMap | null {&#10;    return {&#10;      div: (node: Node) =&gt; ({&#10;        conversion: convertPageBreakElement,&#10;        priority: 1,&#10;      }),&#10;    };&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageBreakNode): PageBreakNode {&#10;    const { pageNumber } = serializedNode;&#10;    const node = $createPageBreakNode(pageNumber);&#10;    return node;&#10;  }&#10;&#10;  exportDOM(): DOMExportOutput {&#10;    const element = document.createElement('div');&#10;    element.setAttribute('data-lexical-page-break', 'true');&#10;    element.setAttribute('data-page-number', this.__pageNumber.toString());&#10;    element.className = 'page-break';&#10;    return { element };&#10;  }&#10;&#10;  exportJSON(): SerializedPageBreakNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      pageNumber: this.__pageNumber,&#10;      type: 'page-break',&#10;      version: 1,&#10;    };&#10;  }&#10;&#10;  canBeEmpty(): false {&#10;    return false;&#10;  }&#10;&#10;  isInline(): false {&#10;    return false;&#10;  }&#10;}&#10;&#10;function convertPageBreakElement(node: HTMLElement): DOMConversionOutput {&#10;  const pageNumber = parseInt(node.getAttribute('data-page-number') || '1', 10);&#10;  const pageBreakNode = $createPageBreakNode(pageNumber);&#10;  return { node: pageBreakNode };&#10;}&#10;&#10;export function $createPageBreakNode(pageNumber: number): PageBreakNode {&#10;  const pageBreakNode = new PageBreakNode(pageNumber);&#10;  const paragraph = $createParagraphNode();&#10;  pageBreakNode.append(paragraph);&#10;  return $applyNodeReplacement(pageBreakNode);&#10;}&#10;&#10;export function $isPageBreakNode(&#10;  node: LexicalNode | null | undefined,&#10;): node is PageBreakNode {&#10;  return node instanceof PageBreakNode;&#10;}&#10;" />
              <option name="updatedContent" value="import {&#10;  $applyNodeReplacement,&#10;  $createParagraphNode,&#10;  ElementNode,&#10;  type DOMConversionMap,&#10;  type DOMConversionOutput,&#10;  type DOMExportOutput,&#10;  type EditorConfig,&#10;  type LexicalNode,&#10;  type NodeKey,&#10;  type SerializedElementNode,&#10;  type Spread,&#10;} from 'lexical';&#10;&#10;export type SerializedPageBreakNode = Spread&lt;&#10;  {&#10;    pageNumber: number;&#10;  },&#10;  SerializedElementNode&#10;&gt;;&#10;&#10;export class PageBreakNode extends ElementNode {&#10;  __pageNumber: number;&#10;&#10;  static getType(): string {&#10;    return 'page-break';&#10;  }&#10;&#10;  static clone(node: PageBreakNode): PageBreakNode {&#10;    return new PageBreakNode(node.__pageNumber, node.__key);&#10;  }&#10;&#10;  constructor(pageNumber: number, key?: NodeKey) {&#10;    super(key);&#10;    this.__pageNumber = pageNumber;&#10;  }&#10;&#10;  getPageNumber(): number {&#10;    return this.__pageNumber;&#10;  }&#10;&#10;  setPageNumber(pageNumber: number): void {&#10;    const writable = this.getWritable();&#10;    writable.__pageNumber = pageNumber;&#10;  }&#10;&#10;  createDOM(config: EditorConfig): HTMLElement {&#10;    const element = document.createElement('div');&#10;    element.setAttribute('data-lexical-page-break', 'true');&#10;    element.setAttribute('data-page-number', this.__pageNumber.toString());&#10;    element.className = 'page-break';&#10;    return element;&#10;  }&#10;&#10;  updateDOM(): false {&#10;    return false;&#10;  }&#10;&#10;  static importDOM(): DOMConversionMap | null {&#10;    return {&#10;      div: () =&gt; ({&#10;        conversion: convertPageBreakElement,&#10;        priority: 1,&#10;      }),&#10;    };&#10;  }&#10;&#10;  static importJSON(serializedNode: SerializedPageBreakNode): PageBreakNode {&#10;    const { pageNumber } = serializedNode;&#10;    return $createPageBreakNode(pageNumber);&#10;  }&#10;&#10;  exportDOM(): DOMExportOutput {&#10;    const element = document.createElement('div');&#10;    element.setAttribute('data-lexical-page-break', 'true');&#10;    element.setAttribute('data-page-number', this.__pageNumber.toString());&#10;    element.className = 'page-break';&#10;    return { element };&#10;  }&#10;&#10;  exportJSON(): SerializedPageBreakNode {&#10;    return {&#10;      ...super.exportJSON(),&#10;      pageNumber: this.__pageNumber,&#10;      type: 'page-break',&#10;      version: 1,&#10;    };&#10;  }&#10;&#10;  canBeEmpty(): false {&#10;    return false;&#10;  }&#10;&#10;  isInline(): false {&#10;    return false;&#10;  }&#10;}&#10;&#10;function convertPageBreakElement(node: HTMLElement): DOMConversionOutput {&#10;  const pageNumberAttr = node.getAttribute('data-page-number');&#10;  const pageNumber = pageNumberAttr ? parseInt(pageNumberAttr, 10) : 1;&#10;  const pageBreakNode = $createPageBreakNode(pageNumber);&#10;  return { node: pageBreakNode };&#10;}&#10;&#10;export function $createPageBreakNode(pageNumber: number): PageBreakNode {&#10;  const pageBreakNode = new PageBreakNode(pageNumber);&#10;  const paragraph = $createParagraphNode();&#10;  pageBreakNode.append(paragraph);&#10;  return $applyNodeReplacement(pageBreakNode);&#10;}&#10;&#10;export function $isPageBreakNode(&#10;  node: LexicalNode | null | undefined,&#10;): node is PageBreakNode {&#10;  return node instanceof PageBreakNode;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationPlugin.tsx" />
              <option name="originalContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import {&#10;  $getRoot,&#10;  $getSelection,&#10;  $isRangeSelection,&#10;  $createParagraphNode,&#10;  COMMAND_PRIORITY_LOW,&#10;  KEY_ARROW_DOWN_COMMAND,&#10;  KEY_ARROW_UP_COMMAND,&#10;  KEY_ENTER_COMMAND,&#10;  SELECTION_CHANGE_COMMAND&#10;} from 'lexical';&#10;import { useEffect, useState, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, PageBreakNode } from './PaginationNode';&#10;import { mergeRegister } from '@lexical/utils';&#10;&#10;interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;const DEFAULT_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210, // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20&#10;};&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_SETTINGS,&#10;  onPageCountChange&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const [pageCount, setPageCount] = useState(1);&#10;  const finalSettings = { ...DEFAULT_SETTINGS, ...settings };&#10;&#10;  // Calculate available content height per page&#10;  const contentHeight = finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: { index: number; pageNumber: number }[] = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Remove existing page breaks first&#10;      children.forEach((child, index) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach(pageBreak =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              // Need a page break before this element&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const pageBreak = $createPageBreakNode(pageNumber);&#10;        if (index &lt; root.getChildrenSize()) {&#10;          const nodeAtIndex = root.getChildAtIndex(index);&#10;          if (nodeAtIndex) {&#10;            nodeAtIndex.insertBefore(pageBreak);&#10;          }&#10;        } else {&#10;          root.append(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      if (newPageCount !== pageCount) {&#10;        setPageCount(newPageCount);&#10;        onPageCountChange?.(newPageCount);&#10;      }&#10;    });&#10;  }, [editor, contentHeight, pageCount, onPageCountChange]);&#10;&#10;  const handleCursorMovement = useCallback(() =&gt; {&#10;    const selection = $getSelection();&#10;    if ($isRangeSelection(selection)) {&#10;      const anchorNode = selection.anchor.getNode();&#10;      const pageBreakParent = anchorNode.getParent();&#10;&#10;      if ($isPageBreakNode(pageBreakParent)) {&#10;        // Move cursor to the paragraph inside the page break&#10;        const paragraph = pageBreakParent.getFirstChild();&#10;        if (paragraph) {&#10;          selection.anchor.set(paragraph.getKey(), 0, 'element');&#10;          selection.focus.set(paragraph.getKey(), 0, 'element');&#10;        }&#10;      }&#10;    }&#10;  }, []);&#10;&#10;  const createNewPageAtCursor = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        const anchorNode = selection.anchor.getNode();&#10;        let insertionPoint = anchorNode;&#10;&#10;        // Find the appropriate insertion point&#10;        while (insertionPoint.getParent() &amp;&amp; insertionPoint.getParent() !== $getRoot()) {&#10;          insertionPoint = insertionPoint.getParent();&#10;        }&#10;&#10;        // Determine the page number for the new page&#10;        const root = $getRoot();&#10;        const children = root.getChildren();&#10;        let newPageNumber = 1;&#10;&#10;        for (const child of children) {&#10;          if ($isPageBreakNode(child)) {&#10;            newPageNumber = Math.max(newPageNumber, child.getPageNumber() + 1);&#10;          }&#10;        }&#10;&#10;        // Create new page break&#10;        const newPageBreak = $createPageBreakNode(newPageNumber);&#10;        insertionPoint.insertAfter(newPageBreak);&#10;&#10;        // Move cursor to the new page&#10;        const newParagraph = newPageBreak.getFirstChild();&#10;        if (newParagraph) {&#10;          selection.anchor.set(newParagraph.getKey(), 0, 'element');&#10;          selection.focus.set(newParagraph.getKey(), 0, 'element');&#10;        }&#10;      }&#10;    });&#10;  }, [editor]);&#10;&#10;  useEffect(() =&gt; {&#10;    return mergeRegister(&#10;      editor.registerUpdateListener(({ editorState, dirtyElements, dirtyLeaves }) =&gt; {&#10;        if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;          // Debounce the page break calculation&#10;          setTimeout(() =&gt; {&#10;            checkForPageBreak();&#10;          }, 100);&#10;        }&#10;      }),&#10;&#10;      editor.registerCommand(&#10;        SELECTION_CHANGE_COMMAND,&#10;        () =&gt; {&#10;          handleCursorMovement();&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW,&#10;      ),&#10;&#10;      editor.registerCommand(&#10;        KEY_ENTER_COMMAND,&#10;        (event) =&gt; {&#10;          if (event?.ctrlKey || event?.metaKey) {&#10;            // Ctrl/Cmd + Enter creates a new page&#10;            createNewPageAtCursor();&#10;            return true;&#10;          }&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW,&#10;      ),&#10;&#10;      editor.registerCommand(&#10;        KEY_ARROW_DOWN_COMMAND,&#10;        () =&gt; {&#10;          handleCursorMovement();&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW,&#10;      ),&#10;&#10;      editor.registerCommand(&#10;        KEY_ARROW_UP_COMMAND,&#10;        () =&gt; {&#10;          handleCursorMovement();&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW,&#10;      ),&#10;    );&#10;  }, [editor, checkForPageBreak, handleCursorMovement, createNewPageAtCursor]);&#10;&#10;  // Initial page break calculation&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; clearTimeout(timer);&#10;  }, [checkForPageBreak]);&#10;&#10;  return null;&#10;}&#10;&#10;export { DEFAULT_SETTINGS as defaultPaginationSettings };&#10;export type { PaginationSettings };&#10;" />
              <option name="updatedContent" value="import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';&#10;import {&#10;  $getRoot,&#10;  $getSelection,&#10;  $isRangeSelection,&#10;  COMMAND_PRIORITY_LOW,&#10;  KEY_ARROW_DOWN_COMMAND,&#10;  KEY_ARROW_UP_COMMAND,&#10;  KEY_ENTER_COMMAND,&#10;  SELECTION_CHANGE_COMMAND,&#10;} from 'lexical';&#10;import { useEffect, useState, useCallback } from 'react';&#10;import { $createPageBreakNode, $isPageBreakNode, type PageBreakNode } from './PaginationNode';&#10;import { mergeRegister } from '@lexical/utils';&#10;&#10;interface PaginationSettings {&#10;  pageHeight: number; // mm&#10;  pageWidth: number; // mm&#10;  marginTop: number; // mm&#10;  marginBottom: number; // mm&#10;  marginLeft: number; // mm&#10;  marginRight: number; // mm&#10;}&#10;&#10;const DEFAULT_SETTINGS: PaginationSettings = {&#10;  pageHeight: 297, // A4 height&#10;  pageWidth: 210, // A4 width&#10;  marginTop: 25,&#10;  marginBottom: 25,&#10;  marginLeft: 20,&#10;  marginRight: 20,&#10;};&#10;&#10;export function PaginationPlugin({&#10;  settings = DEFAULT_SETTINGS,&#10;  onPageCountChange,&#10;}: {&#10;  settings?: Partial&lt;PaginationSettings&gt;;&#10;  onPageCountChange?: (pageCount: number) =&gt; void;&#10;}): null {&#10;  const [editor] = useLexicalComposerContext();&#10;  const [pageCount, setPageCount] = useState(1);&#10;  const finalSettings = { ...DEFAULT_SETTINGS, ...settings };&#10;&#10;  // Calculate available content height per page&#10;  const contentHeight = finalSettings.pageHeight - finalSettings.marginTop - finalSettings.marginBottom;&#10;&#10;  const checkForPageBreak = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const root = $getRoot();&#10;      const children = root.getChildren();&#10;      let currentPageHeight = 0;&#10;      let currentPageNumber = 1;&#10;      const pageBreaksToAdd: Array&lt;{ index: number; pageNumber: number }&gt; = [];&#10;      const existingPageBreaks: PageBreakNode[] = [];&#10;&#10;      // Remove existing page breaks first&#10;      children.forEach((child) =&gt; {&#10;        if ($isPageBreakNode(child)) {&#10;          existingPageBreaks.push(child);&#10;        }&#10;      });&#10;&#10;      // Remove all existing page breaks&#10;      existingPageBreaks.forEach(pageBreak =&gt; {&#10;        pageBreak.remove();&#10;      });&#10;&#10;      // Recalculate page breaks&#10;      const updatedChildren = root.getChildren();&#10;      updatedChildren.forEach((child, index) =&gt; {&#10;        if (!$isPageBreakNode(child)) {&#10;          const element = editor.getElementByKey(child.getKey());&#10;          if (element !== null) {&#10;            const elementHeight = element.offsetHeight;&#10;            const elementHeightMm = (elementHeight * 25.4) / 96; // Convert px to mm&#10;&#10;            if (currentPageHeight + elementHeightMm &gt; contentHeight) {&#10;              // Need a page break before this element&#10;              pageBreaksToAdd.push({ index, pageNumber: currentPageNumber + 1 });&#10;              currentPageNumber++;&#10;              currentPageHeight = elementHeightMm;&#10;            } else {&#10;              currentPageHeight += elementHeightMm;&#10;            }&#10;          }&#10;        }&#10;      });&#10;&#10;      // Add page breaks&#10;      pageBreaksToAdd.reverse().forEach(({ index, pageNumber }) =&gt; {&#10;        const pageBreak = $createPageBreakNode(pageNumber);&#10;        if (index &lt; root.getChildrenSize()) {&#10;          const nodeAtIndex = root.getChildAtIndex(index);&#10;          if (nodeAtIndex !== null) {&#10;            nodeAtIndex.insertBefore(pageBreak);&#10;          }&#10;        } else {&#10;          root.append(pageBreak);&#10;        }&#10;      });&#10;&#10;      // Update page count&#10;      const newPageCount = Math.max(1, currentPageNumber);&#10;      if (newPageCount !== pageCount) {&#10;        setPageCount(newPageCount);&#10;        onPageCountChange?.(newPageCount);&#10;      }&#10;    });&#10;  }, [editor, contentHeight, pageCount, onPageCountChange]);&#10;&#10;  const handleCursorMovement = useCallback(() =&gt; {&#10;    const selection = $getSelection();&#10;    if ($isRangeSelection(selection)) {&#10;      const anchorNode = selection.anchor.getNode();&#10;      const pageBreakParent = anchorNode.getParent();&#10;      &#10;      if ($isPageBreakNode(pageBreakParent)) {&#10;        // Move cursor to the paragraph inside the page break&#10;        const paragraph = pageBreakParent.getFirstChild();&#10;        if (paragraph !== null) {&#10;          selection.anchor.set(paragraph.getKey(), 0, 'element');&#10;          selection.focus.set(paragraph.getKey(), 0, 'element');&#10;        }&#10;      }&#10;    }&#10;  }, []);&#10;&#10;  const createNewPageAtCursor = useCallback(() =&gt; {&#10;    editor.update(() =&gt; {&#10;      const selection = $getSelection();&#10;      if ($isRangeSelection(selection)) {&#10;        const insertionNode = selection.anchor.getNode();&#10;        let insertionPoint = insertionNode;&#10;        &#10;        // Find the appropriate insertion point&#10;        while (insertionPoint.getParent() !== null &amp;&amp; insertionPoint.getParent() !== $getRoot()) {&#10;          const parent = insertionPoint.getParent();&#10;          if (parent !== null) {&#10;            insertionPoint = parent;&#10;          } else {&#10;            break;&#10;          }&#10;        }&#10;&#10;        // Determine the page number for the new page&#10;        const root = $getRoot();&#10;        const children = root.getChildren();&#10;        let newPageNumber = 1;&#10;        &#10;        for (const child of children) {&#10;          if ($isPageBreakNode(child)) {&#10;            newPageNumber = Math.max(newPageNumber, child.getPageNumber() + 1);&#10;          }&#10;        }&#10;&#10;        // Create new page break&#10;        const newPageBreak = $createPageBreakNode(newPageNumber);&#10;        insertionPoint.insertAfter(newPageBreak);&#10;&#10;        // Move cursor to the new page&#10;        const newParagraph = newPageBreak.getFirstChild();&#10;        if (newParagraph !== null) {&#10;          selection.anchor.set(newParagraph.getKey(), 0, 'element');&#10;          selection.focus.set(newParagraph.getKey(), 0, 'element');&#10;        }&#10;      }&#10;    });&#10;  }, [editor]);&#10;&#10;  useEffect(() =&gt; {&#10;    return mergeRegister(&#10;      editor.registerUpdateListener(({ dirtyElements, dirtyLeaves }) =&gt; {&#10;        if (dirtyElements.size &gt; 0 || dirtyLeaves.size &gt; 0) {&#10;          // Debounce the page break calculation&#10;          setTimeout(() =&gt; {&#10;            checkForPageBreak();&#10;          }, 100);&#10;        }&#10;      }),&#10;&#10;      editor.registerCommand(&#10;        SELECTION_CHANGE_COMMAND,&#10;        () =&gt; {&#10;          handleCursorMovement();&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW&#10;      ),&#10;&#10;      editor.registerCommand(&#10;        KEY_ENTER_COMMAND,&#10;        (event) =&gt; {&#10;          if ((event?.ctrlKey ?? false) || (event?.metaKey ?? false)) {&#10;            // Ctrl/Cmd + Enter creates a new page&#10;            createNewPageAtCursor();&#10;            return true;&#10;          }&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW&#10;      ),&#10;&#10;      editor.registerCommand(&#10;        KEY_ARROW_DOWN_COMMAND,&#10;        () =&gt; {&#10;          handleCursorMovement();&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW&#10;      ),&#10;&#10;      editor.registerCommand(&#10;        KEY_ARROW_UP_COMMAND,&#10;        () =&gt; {&#10;          handleCursorMovement();&#10;          return false;&#10;        },&#10;        COMMAND_PRIORITY_LOW&#10;      )&#10;    );&#10;  }, [editor, checkForPageBreak, handleCursorMovement, createNewPageAtCursor]);&#10;&#10;  // Initial page break calculation&#10;  useEffect(() =&gt; {&#10;    const timer = setTimeout(() =&gt; {&#10;      checkForPageBreak();&#10;    }, 500);&#10;&#10;    return () =&gt; {&#10;      clearTimeout(timer);&#10;    };&#10;  }, [checkForPageBreak]);&#10;&#10;  return null;&#10;}&#10;&#10;export { DEFAULT_SETTINGS as defaultPaginationSettings };&#10;export type { PaginationSettings };" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettings.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/PaginationSettings.tsx" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import { PaginationSettings } from './PaginationPlugin';&#10;&#10;interface PaginationSettingsProps {&#10;  settings: PaginationSettings;&#10;  onSettingsChange: (settings: PaginationSettings) =&gt; void;&#10;  isVisible: boolean;&#10;  onToggle: () =&gt; void;&#10;}&#10;&#10;export function PaginationSettingsPanel({&#10;  settings,&#10;  onSettingsChange,&#10;  isVisible,&#10;  onToggle,&#10;}: PaginationSettingsProps): JSX.Element {&#10;  const [localSettings, setLocalSettings] = useState(settings);&#10;&#10;  const handleChange = (field: keyof PaginationSettings, value: number) =&gt; {&#10;    const newSettings = { ...localSettings, [field]: value };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  const presets = {&#10;    A4: { pageWidth: 210, pageHeight: 297 },&#10;    A3: { pageWidth: 297, pageHeight: 420 },&#10;    Letter: { pageWidth: 216, pageHeight: 279 },&#10;    Legal: { pageWidth: 216, pageHeight: 356 },&#10;  };&#10;&#10;  const applyPreset = (preset: keyof typeof presets) =&gt; {&#10;    const newSettings = {&#10;      ...localSettings,&#10;      ...presets[preset]&#10;    };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  if (!isVisible) {&#10;    return (&#10;      &lt;button className=&quot;pagination-control-btn settings-toggle&quot; onClick={onToggle}&gt;&#10;        ⚙️&#10;      &lt;/button&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;page-settings&quot;&gt;&#10;      &lt;div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}&gt;&#10;        &lt;h3&gt;Sayfa Ayarları&lt;/h3&gt;&#10;        &lt;button&#10;          onClick={onToggle}&#10;          style={{&#10;            background: 'none',&#10;            border: 'none',&#10;            cursor: 'pointer',&#10;            fontSize: '16px'&#10;          }}&#10;        &gt;&#10;          ✕&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div style={{ marginBottom: '12px' }}&gt;&#10;        &lt;label&gt;Sayfa Boyutu Önayarları:&lt;/label&gt;&#10;        &lt;div style={{ display: 'flex', gap: '4px', marginTop: '4px' }}&gt;&#10;          {Object.keys(presets).map((preset) =&gt; (&#10;            &lt;button&#10;              key={preset}&#10;              onClick={() =&gt; applyPreset(preset as keyof typeof presets)}&#10;              style={{&#10;                padding: '4px 8px',&#10;                border: '1px solid #d1d1d1',&#10;                borderRadius: '2px',&#10;                background: 'white',&#10;                cursor: 'pointer',&#10;                fontSize: '10px',&#10;              }}&#10;            &gt;&#10;              {preset}&#10;            &lt;/button&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;label&gt;&#10;        Genişlik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageWidth}&#10;          onChange={(e) =&gt; handleChange('pageWidth', Number(e.target.value))}&#10;          min=&quot;100&quot;&#10;          max=&quot;500&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Yükseklik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageHeight}&#10;          onChange={(e) =&gt; handleChange('pageHeight', Number(e.target.value))}&#10;          min=&quot;100&quot;&#10;          max=&quot;700&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Üst Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginTop}&#10;          onChange={(e) =&gt; handleChange('marginTop', Number(e.target.value))}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Alt Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginBottom}&#10;          onChange={(e) =&gt; handleChange('marginBottom', Number(e.target.value))}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sol Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginLeft}&#10;          onChange={(e) =&gt; handleChange('marginLeft', Number(e.target.value))}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sağ Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginRight}&#10;          onChange={(e) =&gt; handleChange('marginRight', Number(e.target.value))}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;div style={{ marginTop: '12px', fontSize: '10px', color: '#666' }}&gt;&#10;        Ctrl+Enter: Yeni sayfa ekle&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useState } from 'react';&#10;import type { PaginationSettings } from './PaginationPlugin';&#10;&#10;interface PaginationSettingsProps {&#10;  settings: PaginationSettings;&#10;  onSettingsChange: (settings: PaginationSettings) =&gt; void;&#10;  isVisible: boolean;&#10;  onToggle: () =&gt; void;&#10;}&#10;&#10;export function PaginationSettingsPanel({&#10;  settings,&#10;  onSettingsChange,&#10;  isVisible,&#10;  onToggle,&#10;}: PaginationSettingsProps): JSX.Element {&#10;  const [localSettings, setLocalSettings] = useState(settings);&#10;&#10;  const handleChange = (field: keyof PaginationSettings, value: number): void =&gt; {&#10;    const newSettings = { ...localSettings, [field]: value };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  const presets = {&#10;    A4: { pageWidth: 210, pageHeight: 297 },&#10;    A3: { pageWidth: 297, pageHeight: 420 },&#10;    Letter: { pageWidth: 216, pageHeight: 279 },&#10;    Legal: { pageWidth: 216, pageHeight: 356 },&#10;  };&#10;&#10;  const applyPreset = (preset: keyof typeof presets): void =&gt; {&#10;    const newSettings = {&#10;      ...localSettings,&#10;      ...presets[preset],&#10;    };&#10;    setLocalSettings(newSettings);&#10;    onSettingsChange(newSettings);&#10;  };&#10;&#10;  if (!isVisible) {&#10;    return (&#10;      &lt;button className=&quot;pagination-control-btn settings-toggle&quot; onClick={onToggle}&gt;&#10;        ⚙️&#10;      &lt;/button&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;page-settings&quot;&gt;&#10;      &lt;div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}&gt;&#10;        &lt;h3&gt;Sayfa Ayarları&lt;/h3&gt;&#10;        &lt;button&#10;          onClick={onToggle}&#10;          style={{&#10;            background: 'none',&#10;            border: 'none',&#10;            cursor: 'pointer',&#10;            fontSize: '16px'&#10;          }}&#10;        &gt;&#10;          ✕&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div style={{ marginBottom: '12px' }}&gt;&#10;        &lt;label&gt;Sayfa Boyutu Önayarları:&lt;/label&gt;&#10;        &lt;div style={{ display: 'flex', gap: '4px', marginTop: '4px' }}&gt;&#10;          {Object.keys(presets).map((preset) =&gt; (&#10;            &lt;button&#10;              key={preset}&#10;              onClick={() =&gt; {&#10;                applyPreset(preset as keyof typeof presets);&#10;              }}&#10;              style={{&#10;                padding: '4px 8px',&#10;                border: '1px solid #d1d1d1',&#10;                borderRadius: '2px',&#10;                background: 'white',&#10;                cursor: 'pointer',&#10;                fontSize: '10px',&#10;              }}&#10;            &gt;&#10;              {preset}&#10;            &lt;/button&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;label&gt;&#10;        Genişlik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageWidth}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageWidth', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;500&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Yükseklik (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.pageHeight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('pageHeight', Number(e.target.value));&#10;          }}&#10;          min=&quot;100&quot;&#10;          max=&quot;700&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Üst Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginTop}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginTop', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Alt Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginBottom}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginBottom', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sol Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginLeft}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginLeft', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;label&gt;&#10;        Sağ Kenar Boşluğu (mm):&#10;        &lt;input&#10;          type=&quot;number&quot;&#10;          value={localSettings.marginRight}&#10;          onChange={(e) =&gt; {&#10;            handleChange('marginRight', Number(e.target.value));&#10;          }}&#10;          min=&quot;5&quot;&#10;          max=&quot;50&quot;&#10;        /&gt;&#10;      &lt;/label&gt;&#10;&#10;      &lt;div style={{ marginTop: '12px', fontSize: '10px', color: '#666' }}&gt;&#10;        Ctrl+Enter: Yeni sayfa ekle&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/styles.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/plugins/pagination/styles.css" />
              <option name="updatedContent" value="/* Pagination styles for Word-like page breaks */&#10;.page-break {&#10;  position: relative;&#10;  width: 100%;&#10;  min-height: calc(297mm - 50mm); /* A4 height minus margins */&#10;  background: white;&#10;  margin-bottom: 20px;&#10;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#10;  border-radius: 2px;&#10;  page-break-after: always;&#10;  display: flex;&#10;  flex-direction: column;&#10;}&#10;&#10;.page-break::before {&#10;  content: &quot;Sayfa &quot; attr(data-page-number);&#10;  position: absolute;&#10;  top: -25px;&#10;  left: 50%;&#10;  transform: translateX(-50%);&#10;  font-size: 9pt;&#10;  color: #666;&#10;  background: #f3f2f1;&#10;  padding: 2px 8px;&#10;  border-radius: 3px;&#10;  font-family: 'Segoe UI', system-ui, sans-serif;&#10;  z-index: 10;&#10;}&#10;&#10;.page-break &gt; p {&#10;  margin: 0;&#10;  padding: 25mm 20mm;&#10;  flex: 1;&#10;  min-height: calc(297mm - 50mm);&#10;  font-family: 'Calibri', 'Times New Roman', serif;&#10;  font-size: 11pt;&#10;  line-height: 1.15;&#10;  color: #000;&#10;  outline: none;&#10;  border: none;&#10;  background: transparent;&#10;}&#10;&#10;.page-break &gt; p:focus {&#10;  outline: none;&#10;}&#10;&#10;/* Page container for multiple pages */&#10;.pages-container {&#10;  display: flex;&#10;  flex-direction: column;&#10;  align-items: center;&#10;  gap: 20px;&#10;  max-width: 210mm;&#10;  margin: 0 auto;&#10;}&#10;&#10;/* Updated editor container for pagination */&#10;.editor-container.paginated {&#10;  background: #f3f2f1;&#10;  min-height: 100vh;&#10;  padding: 20px;&#10;}&#10;&#10;.editor-container.paginated .a4-page {&#10;  box-shadow: none;&#10;  background: transparent;&#10;  margin-bottom: 0;&#10;}&#10;&#10;.editor-container.paginated .contentEditable {&#10;  padding: 25mm 20mm;&#10;  background: white;&#10;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#10;  border-radius: 2px;&#10;  margin-bottom: 20px;&#10;}&#10;&#10;/* Page number indicator */&#10;.page-indicator {&#10;  position: fixed;&#10;  bottom: 20px;&#10;  right: 20px;&#10;  background: rgba(0, 0, 0, 0.8);&#10;  color: white;&#10;  padding: 8px 12px;&#10;  border-radius: 4px;&#10;  font-size: 12px;&#10;  font-family: 'Segoe UI', system-ui, sans-serif;&#10;  z-index: 1000;&#10;}&#10;&#10;/* Pagination controls */&#10;.pagination-controls {&#10;  position: fixed;&#10;  top: 50%;&#10;  right: 20px;&#10;  transform: translateY(-50%);&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;  z-index: 1000;&#10;}&#10;&#10;.pagination-control-btn {&#10;  background: white;&#10;  border: 1px solid #d1d1d1;&#10;  border-radius: 4px;&#10;  padding: 8px;&#10;  cursor: pointer;&#10;  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);&#10;  transition: all 0.2s ease;&#10;}&#10;&#10;.pagination-control-btn:hover {&#10;  background: #f5f5f5;&#10;  border-color: #0078d4;&#10;}&#10;&#10;.pagination-control-btn:active {&#10;  transform: scale(0.95);&#10;}&#10;&#10;/* Page settings panel */&#10;.page-settings {&#10;  position: fixed;&#10;  top: 20px;&#10;  left: 20px;&#10;  background: white;&#10;  border: 1px solid #d1d1d1;&#10;  border-radius: 4px;&#10;  padding: 16px;&#10;  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);&#10;  z-index: 1000;&#10;  font-family: 'Segoe UI', system-ui, sans-serif;&#10;  font-size: 12px;&#10;}&#10;&#10;.page-settings h3 {&#10;  margin: 0 0 12px 0;&#10;  font-size: 14px;&#10;  color: #323130;&#10;}&#10;&#10;.page-settings label {&#10;  display: block;&#10;  margin-bottom: 8px;&#10;  color: #605e5c;&#10;}&#10;&#10;.page-settings input {&#10;  width: 60px;&#10;  padding: 4px 6px;&#10;  border: 1px solid #d1d1d1;&#10;  border-radius: 2px;&#10;  font-size: 11px;&#10;}&#10;&#10;.page-settings input:focus {&#10;  outline: none;&#10;  border-color: #0078d4;&#10;}&#10;&#10;/* Responsive design */&#10;@media (max-width: 768px) {&#10;  .page-break {&#10;    min-height: auto;&#10;    margin-bottom: 10px;&#10;  }&#10;  &#10;  .page-break &gt; p {&#10;    padding: 15mm 10mm;&#10;    min-height: auto;&#10;  }&#10;  &#10;  .pagination-controls,&#10;  .page-settings {&#10;    display: none;&#10;  }&#10;  &#10;  .page-indicator {&#10;    bottom: 10px;&#10;    right: 10px;&#10;    font-size: 11px;&#10;    padding: 6px 10px;&#10;  }&#10;}&#10;&#10;/* Print styles */&#10;@media print {&#10;  .page-break {&#10;    box-shadow: none;&#10;    margin-bottom: 0;&#10;    page-break-after: always;&#10;  }&#10;  &#10;  .page-break::before {&#10;    display: none;&#10;  }&#10;  &#10;  .pagination-controls,&#10;  .page-settings,&#10;  .page-indicator {&#10;    display: none !important;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/glyf-editor/styles.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/glyf-editor/styles.css" />
              <option name="originalContent" value="/* Sade ve temiz A4 Word benzeri tasarım */&#10;.editor-container {&#10;  display: flex;&#10;  justify-content: center;&#10;  background: #f3f2f1;&#10;  min-height: 100vh;&#10;  padding: 20px;&#10;  font-family: 'Segoe UI', system-ui, sans-serif;&#10;}&#10;&#10;/* Temiz A4 sayfa tasarımı */&#10;.a4-page {&#10;  width: 210mm;&#10;  min-height: 297mm;&#10;  background: white;&#10;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#10;  margin: 0 auto;&#10;  display: flex;&#10;  flex-direction: column;&#10;  border-radius: 2px;&#10;}&#10;&#10;/* A4 içerik alanı - sade */&#10;.a4-content {&#10;  flex: 1;&#10;  position: relative;&#10;}&#10;&#10;/* Toolbar - minimal tasarım */&#10;.toolbar-wrapper {&#10;  background: #fafafa;&#10;  border-bottom: 1px solid #e0e0e0;&#10;  border-radius: 2px 2px 0 0;&#10;}&#10;&#10;/* Ana yazı alanı - Word benzeri */&#10;.contentEditable {&#10;  width: 100%;&#10;  min-height: calc(297mm - 60px);&#10;  border: none;&#10;  outline: none;&#10;  font-family: 'Calibri', 'Times New Roman', serif;&#10;  font-size: 11pt;&#10;  line-height: 1.15;&#10;  color: #000;&#10;  background: white;&#10;  caret-color: #0078d4;&#10;}&#10;&#10;.contentEditable:focus {&#10;  outline: none;&#10;}&#10;&#10;/* Placeholder - sade */&#10;.placeholder {&#10;  position: absolute;&#10;  top: 25mm;&#10;  left: 20mm;&#10;  color: #999;&#10;  pointer-events: none;&#10;  font-family: 'Calibri', serif;&#10;  font-size: 11pt;&#10;  font-style: italic;&#10;}&#10;&#10;/* Text formatting - basit ve etkili */&#10;.glyf-editor-bold {&#10;  font-weight: 700;&#10;}&#10;&#10;.glyf-editor-italic {&#10;  font-style: italic;&#10;}&#10;&#10;.glyf-editor-underline {&#10;  text-decoration: underline;&#10;}&#10;&#10;.glyf-editor-strikethrough {&#10;  text-decoration: line-through;&#10;}&#10;&#10;.glyf-editor-underlineStrikethrough {&#10;  text-decoration: underline line-through;&#10;}&#10;&#10;/* Başlık stilleri - Word'ün basit versiyonu */&#10;.glyf-editor-h1 {&#10;  font-family: 'Calibri', sans-serif;&#10;  font-size: 16pt;&#10;  font-weight: 600;&#10;  color: #2f5496;&#10;  margin: 0 0 8pt 0;&#10;  line-height: 1.2;&#10;}&#10;&#10;.glyf-editor-h2 {&#10;  font-family: 'Calibri', sans-serif;&#10;  font-size: 13pt;&#10;  font-weight: 600;&#10;  color: #2f5496;&#10;  margin: 8pt 0 6pt 0;&#10;  line-height: 1.2;&#10;}&#10;&#10;.glyf-editor-h3 {&#10;  font-family: 'Calibri', sans-serif;&#10;  font-size: 12pt;&#10;  font-weight: 600;&#10;  color: #1f3763;&#10;  margin: 6pt 0 4pt 0;&#10;  line-height: 1.2;&#10;}&#10;&#10;/* Paragraf - basit Word spacing */&#10;p {&#10;  margin: 0 0 8pt 0;&#10;  font-family: 'Calibri', serif;&#10;  font-size: 11pt;&#10;  line-height: 1.15;&#10;  color: #000;&#10;}&#10;&#10;/* Liste stilleri - minimal */&#10;ul,&#10;ol {&#10;  margin: 0 0 8pt 0;&#10;  padding-left: 18pt;&#10;  font-family: 'Calibri', serif;&#10;  font-size: 11pt;&#10;  line-height: 1.15;&#10;}&#10;&#10;li {&#10;  margin: 0 0 2pt 0;&#10;  padding: 0;&#10;  color: #000;&#10;}&#10;&#10;/* Banner - sade tasarım */&#10;.glyf-editor-banner {&#10;  margin: 8pt 0;&#10;  padding: 8pt 12pt;&#10;  border-left: 3px solid #0078d4;&#10;  background: #f8f9fa;&#10;  border-radius: 0 3px 3px 0;&#10;}&#10;&#10;/* Selection - Word mavi */&#10;::selection {&#10;  background-color: #0078d4;&#10;  color: white;&#10;}&#10;&#10;/* Scrollbar - minimal */&#10;.contentEditable::-webkit-scrollbar {&#10;  width: 8px;&#10;}&#10;&#10;.contentEditable::-webkit-scrollbar-track {&#10;  background: transparent;&#10;}&#10;&#10;.contentEditable::-webkit-scrollbar-thumb {&#10;  background: #ccc;&#10;  border-radius: 4px;&#10;}&#10;&#10;.contentEditable::-webkit-scrollbar-thumb:hover {&#10;  background: #999;&#10;}&#10;&#10;/* Print için temizlik */&#10;@media print {&#10;  .editor-container {&#10;    background: white;&#10;    padding: 0;&#10;  }&#10;&#10;  .a4-page {&#10;    box-shadow: none;&#10;    margin: 0;&#10;    border-radius: 0;&#10;  }&#10;&#10;  .toolbar-wrapper {&#10;    display: none;&#10;  }&#10;&#10;  .contentEditable {&#10;    padding: 20mm;&#10;    font-size: 12pt;&#10;    line-height: 1.5;&#10;  }&#10;}&#10;&#10;/* Responsive - mobil için */&#10;@media (max-width: 768px) {&#10;  .editor-container {&#10;    padding: 10px;&#10;  }&#10;&#10;  .a4-page {&#10;    width: 100%;&#10;    min-width: 300px;&#10;  }&#10;&#10;  .contentEditable {&#10;    padding: 15mm 10mm;&#10;    font-size: 12pt;&#10;  }&#10;&#10;  .placeholder {&#10;    left: 10mm;&#10;    top: 15mm;&#10;    font-size: 12pt;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="/* Sade ve temiz A4 Word benzeri tasarım */&#10;.editor-container {&#10;  display: flex;&#10;  justify-content: center;&#10;  background: #f3f2f1;&#10;  min-height: 100vh;&#10;  padding: 20px;&#10;  font-family: 'Segoe UI', system-ui, sans-serif;&#10;}&#10;&#10;/* Pagination desteği için güncellenmiş container */&#10;.editor-container.paginated {&#10;  flex-direction: column;&#10;  align-items: center;&#10;}&#10;&#10;/* Temiz A4 sayfa tasarımı */&#10;.a4-page {&#10;  width: 210mm;&#10;  min-height: 297mm;&#10;  background: white;&#10;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#10;  margin: 0 auto;&#10;  display: flex;&#10;  flex-direction: column;&#10;  border-radius: 2px;&#10;}&#10;&#10;/* Pagination modunda sayfa düzeni */&#10;.editor-container.paginated .a4-page {&#10;  box-shadow: none;&#10;  background: transparent;&#10;  margin-bottom: 0;&#10;}&#10;&#10;/* A4 içerik alanı - sade */&#10;.a4-content {&#10;  flex: 1;&#10;  position: relative;&#10;}&#10;&#10;/* Toolbar - minimal tasarım */&#10;.toolbar-wrapper {&#10;  background: #fafafa;&#10;  border-bottom: 1px solid #e0e0e0;&#10;  border-radius: 2px 2px 0 0;&#10;}&#10;&#10;/* Pagination modunda toolbar */&#10;.editor-container.paginated .toolbar-wrapper {&#10;  position: sticky;&#10;  top: 0;&#10;  z-index: 100;&#10;  margin-bottom: 20px;&#10;  border-radius: 4px;&#10;  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);&#10;}&#10;&#10;/* Ana yazı alanı - Word benzeri */&#10;.contentEditable {&#10;  width: 100%;&#10;  min-height: calc(297mm - 60px);&#10;  border: none;&#10;  outline: none;&#10;  font-family: 'Calibri', 'Times New Roman', serif;&#10;  font-size: 11pt;&#10;  line-height: 1.15;&#10;  color: #000;&#10;  background: white;&#10;  caret-color: #0078d4;&#10;  padding: 25mm 20mm;&#10;}&#10;&#10;/* Pagination modunda contentEditable */&#10;.editor-container.paginated .contentEditable {&#10;  padding: 25mm 20mm;&#10;  background: white;&#10;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#10;  border-radius: 2px;&#10;  margin-bottom: 20px;&#10;  min-height: auto;&#10;}&#10;&#10;.contentEditable:focus {&#10;  outline: none;&#10;}&#10;&#10;/* Placeholder - sade */&#10;.placeholder {&#10;  position: absolute;&#10;  top: 25mm;&#10;  left: 20mm;&#10;  color: #999;&#10;  pointer-events: none;&#10;  font-family: 'Calibri', serif;&#10;  font-size: 11pt;&#10;  font-style: italic;&#10;}&#10;&#10;/* Text formatting - basit ve etkili */&#10;.glyf-editor-bold {&#10;  font-weight: 700;&#10;}&#10;&#10;.glyf-editor-italic {&#10;  font-style: italic;&#10;}&#10;&#10;.glyf-editor-underline {&#10;  text-decoration: underline;&#10;}&#10;&#10;.glyf-editor-strikethrough {&#10;  text-decoration: line-through;&#10;}&#10;&#10;.glyf-editor-underlineStrikethrough {&#10;  text-decoration: underline line-through;&#10;}&#10;&#10;/* Başlık stilleri - Word'ün basit versiyonu */&#10;.glyf-editor-h1 {&#10;  font-family: 'Calibri', sans-serif;&#10;  font-size: 16pt;&#10;  font-weight: 600;&#10;  color: #2f5496;&#10;  margin: 0 0 8pt 0;&#10;  line-height: 1.2;&#10;}&#10;&#10;.glyf-editor-h2 {&#10;  font-family: 'Calibri', sans-serif;&#10;  font-size: 13pt;&#10;  font-weight: 600;&#10;  color: #2f5496;&#10;  margin: 8pt 0 6pt 0;&#10;  line-height: 1.2;&#10;}&#10;&#10;.glyf-editor-h3 {&#10;  font-family: 'Calibri', sans-serif;&#10;  font-size: 12pt;&#10;  font-weight: 600;&#10;  color: #1f3763;&#10;  margin: 6pt 0 4pt 0;&#10;  line-height: 1.2;&#10;}&#10;&#10;/* Paragraf - basit Word spacing */&#10;p {&#10;  margin: 0 0 8pt 0;&#10;  font-family: 'Calibri', serif;&#10;  font-size: 11pt;&#10;  line-height: 1.15;&#10;  color: #000;&#10;}&#10;&#10;/* Liste stilleri - minimal */&#10;ul,&#10;ol {&#10;  margin: 0 0 8pt 0;&#10;  padding-left: 18pt;&#10;  font-family: 'Calibri', serif;&#10;  font-size: 11pt;&#10;  line-height: 1.15;&#10;}&#10;&#10;li {&#10;  margin: 0 0 2pt 0;&#10;  padding: 0;&#10;  color: #000;&#10;}&#10;&#10;/* Banner - sade tasarım */&#10;.glyf-editor-banner {&#10;  margin: 8pt 0;&#10;  padding: 8pt 12pt;&#10;  border-left: 3px solid #0078d4;&#10;  background: #f8f9fa;&#10;  border-radius: 0 3px 3px 0;&#10;}&#10;&#10;/* Selection - Word mavi */&#10;::selection {&#10;  background-color: #0078d4;&#10;  color: white;&#10;}&#10;&#10;/* Scrollbar - minimal */&#10;.contentEditable::-webkit-scrollbar {&#10;  width: 8px;&#10;}&#10;&#10;.contentEditable::-webkit-scrollbar-track {&#10;  background: transparent;&#10;}&#10;&#10;.contentEditable::-webkit-scrollbar-thumb {&#10;  background: #ccc;&#10;  border-radius: 4px;&#10;}&#10;&#10;.contentEditable::-webkit-scrollbar-thumb:hover {&#10;  background: #999;&#10;}&#10;&#10;/* Print için temizlik */&#10;@media print {&#10;  .editor-container {&#10;    background: white;&#10;    padding: 0;&#10;  }&#10;&#10;  .a4-page {&#10;    box-shadow: none;&#10;    margin: 0;&#10;    border-radius: 0;&#10;  }&#10;&#10;  .toolbar-wrapper {&#10;    display: none;&#10;  }&#10;&#10;  .contentEditable {&#10;    padding: 20mm;&#10;    font-size: 12pt;&#10;    line-height: 1.5;&#10;  }&#10;}&#10;&#10;/* Responsive - mobil için */&#10;@media (max-width: 768px) {&#10;  .editor-container {&#10;    padding: 10px;&#10;  }&#10;&#10;  .a4-page {&#10;    width: 100%;&#10;    min-width: 300px;&#10;  }&#10;&#10;  .contentEditable {&#10;    padding: 15mm 10mm;&#10;    font-size: 12pt;&#10;  }&#10;&#10;  .placeholder {&#10;    left: 10mm;&#10;    top: 15mm;&#10;    font-size: 12pt;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>